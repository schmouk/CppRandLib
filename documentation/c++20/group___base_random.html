<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CppRandLib - c++20: algos: BaseRandom - Base class for all PRNGs (Pseudo Random Numbers Generators)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CppRandLib - c++20<span id="projectnumber">&#160;2.1.2</span>
   </div>
   <div id="projectbrief">Best-in-class Pseudo Random Number Generators</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('group___base_random.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">algos: BaseRandom - Base class for all PRNGs (Pseudo Random Numbers Generators) </div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:BaseRandom_3C_20StateT_2C_20OutputT_2C_20OUTPUT_5FBITS_20_3E" id="r_BaseRandom_3C_20StateT_2C_20OutputT_2C_20OUTPUT_5FBITS_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_base_random.html">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base class for all pseudo-random numbers generators.  <a href="class_base_random.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad247a2374d091a20d7b668474e89e6c4" id="r_gad247a2374d091a20d7b668474e89e6c4"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad247a2374d091a20d7b668474e89e6c4">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::betavariate</a> (const double alpha, const double beta)</td></tr>
<tr class="memdesc:gad247a2374d091a20d7b668474e89e6c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Beta distribution.  <br /></td></tr>
<tr class="memitem:gae9e46564b6f810a9cf529c8b5349727a" id="r_gae9e46564b6f810a9cf529c8b5349727a"><td class="memTemplParams" colspan="2">template&lt;typename CountT, typename ProbaT&gt; <br />
requires std::is_integral_v&lt;CountT&gt;&amp;&amp; std::is_floating_point_v&lt;ProbaT&gt;</td></tr>
<tr class="memitem:gae9e46564b6f810a9cf529c8b5349727a template"><td class="memItemLeft" align="right" valign="top">const CountT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae9e46564b6f810a9cf529c8b5349727a">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::binomialvariate</a> (const CountT n=1, const ProbaT p=ProbaT(0.5))</td></tr>
<tr class="memdesc:gae9e46564b6f810a9cf529c8b5349727a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of successes for n&gt;=0 independent trials.  <br /></td></tr>
<tr class="memitem:gae81fe65366b54ec3a9b2975860ce75b3" id="r_gae81fe65366b54ec3a9b2975860ce75b3"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; <br />
requires std::is_integral_v&lt;OutputT&gt; || std::is_same_v&lt;OutputT, <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a>&gt;</td></tr>
<tr class="memitem:gae81fe65366b54ec3a9b2975860ce75b3 template"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae81fe65366b54ec3a9b2975860ce75b3">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::choice</a> (const std::vector&lt; T &gt; &amp;seq)</td></tr>
<tr class="memdesc:gae81fe65366b54ec3a9b2975860ce75b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chooses a random element from a non-empty sequence (std::vector).  <br /></td></tr>
<tr class="memitem:gabbfd6e6e55f9f53ee50e7529ddae3eba" id="r_gabbfd6e6e55f9f53ee50e7529ddae3eba"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; <br />
requires std::is_integral_v&lt;OutputT&gt; || std::is_same_v&lt;OutputT, <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a>&gt;</td></tr>
<tr class="memitem:gabbfd6e6e55f9f53ee50e7529ddae3eba template"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabbfd6e6e55f9f53ee50e7529ddae3eba">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::choices</a> (const std::vector&lt; T &gt; &amp;population, const std::size_t k)</td></tr>
<tr class="memdesc:gabbfd6e6e55f9f53ee50e7529ddae3eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a k sized vector of elements chosen from the population with replacement (same weights).  <br /></td></tr>
<tr class="memitem:ga23f2f44f6b507dd36b9731242312a6f2" id="r_ga23f2f44f6b507dd36b9731242312a6f2"><td class="memTemplParams" colspan="2">template&lt;typename T, typename C&gt; <br />
requires std::is_arithmetic_v&lt;C&gt;</td></tr>
<tr class="memitem:ga23f2f44f6b507dd36b9731242312a6f2 template"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga23f2f44f6b507dd36b9731242312a6f2">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::choices</a> (const std::vector&lt; T &gt; &amp;population, std::vector&lt; C &gt; &amp;weights, const std::size_t k)</td></tr>
<tr class="memdesc:ga23f2f44f6b507dd36b9731242312a6f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a k sized vector of elements chosen from the population with replacement (individual weights).  <br /></td></tr>
<tr class="memitem:ga1889ab84371fc977b0e9816665e17231" id="r_ga1889ab84371fc977b0e9816665e17231"><td class="memTemplParams" colspan="2">template&lt;typename T, typename C&gt; <br />
requires std::is_arithmetic_v&lt;C&gt;</td></tr>
<tr class="memitem:ga1889ab84371fc977b0e9816665e17231 template"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1889ab84371fc977b0e9816665e17231">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::choices_cum</a> (const std::vector&lt; T &gt; &amp;population, const std::vector&lt; C &gt; &amp;cum_weights, const std::size_t k)</td></tr>
<tr class="memdesc:ga1889ab84371fc977b0e9816665e17231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a k sized vector of elements chosen from the population with replacement (cumulative weights).  <br /></td></tr>
<tr class="memitem:gad6d05022f14a2c7c07a069f8bfec1726" id="r_gad6d05022f14a2c7c07a069f8bfec1726"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad6d05022f14a2c7c07a069f8bfec1726">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::expovariate</a> (const double lambda=1.0)</td></tr>
<tr class="memdesc:gad6d05022f14a2c7c07a069f8bfec1726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exponential distribution.  <br /></td></tr>
<tr class="memitem:ga936e58e8231d9194bf32d9338999bff4" id="r_ga936e58e8231d9194bf32d9338999bff4"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga936e58e8231d9194bf32d9338999bff4">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::gammavariate</a> (const double alpha, const double beta)</td></tr>
<tr class="memdesc:ga936e58e8231d9194bf32d9338999bff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gamma distribution. This is NOT the gamma function!  <br /></td></tr>
<tr class="memitem:ga3638eab8f6adf1da44e9e1d18b69145f" id="r_ga3638eab8f6adf1da44e9e1d18b69145f"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3638eab8f6adf1da44e9e1d18b69145f">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::gauss</a> () noexcept</td></tr>
<tr class="memdesc:ga3638eab8f6adf1da44e9e1d18b69145f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Gaussian distribution (mean=0.0, stdev=1.0).  <br /></td></tr>
<tr class="memitem:ga3f118338c6e34fb76adb2343edfd3ace" id="r_ga3f118338c6e34fb76adb2343edfd3ace"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3f118338c6e34fb76adb2343edfd3ace">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::gauss</a> (const double mu, const double sigma)</td></tr>
<tr class="memdesc:ga3f118338c6e34fb76adb2343edfd3ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gaussian distribution (mean=mu, stdev=sigma).  <br /></td></tr>
<tr class="memitem:ga61460bcb665bc5c7ac684d272ff34c99" id="r_ga61460bcb665bc5c7ac684d272ff34c99"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga61460bcb665bc5c7ac684d272ff34c99">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::lognormvariate</a> ()</td></tr>
<tr class="memdesc:ga61460bcb665bc5c7ac684d272ff34c99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Log normal distribution (mean=0.0, stdev=1.0).  <br /></td></tr>
<tr class="memitem:gaac53fbbe5df64d8471764b650c4c9612" id="r_gaac53fbbe5df64d8471764b650c4c9612"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaac53fbbe5df64d8471764b650c4c9612">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::lognormvariate</a> (const double mu, const double sigma)</td></tr>
<tr class="memdesc:gaac53fbbe5df64d8471764b650c4c9612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log normal distribution (mean=mu, stdev=sigma).  <br /></td></tr>
<tr class="memitem:gaa1658d6f0081d7d78e0816a9e4b80b16" id="r_gaa1658d6f0081d7d78e0816a9e4b80b16"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; <br />
requires std::is_floating_point_v&lt;T&gt;</td></tr>
<tr class="memitem:gaa1658d6f0081d7d78e0816a9e4b80b16 template"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa1658d6f0081d7d78e0816a9e4b80b16">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::n_evaluate</a> (const std::size_t n)</td></tr>
<tr class="memdesc:gaa1658d6f0081d7d78e0816a9e4b80b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of n values that are uniformly contained within range [0.0, 1.0).  <br /></td></tr>
<tr class="memitem:gad2e569db15494aecaadd2f4a10994cb8" id="r_gad2e569db15494aecaadd2f4a10994cb8"><td class="memTemplParams" colspan="2">template&lt;typename T, typename U = T&gt; <br />
requires std::is_arithmetic_v&lt;T&gt; &amp;&amp; std::is_arithmetic_v&lt;U&gt;</td></tr>
<tr class="memitem:gad2e569db15494aecaadd2f4a10994cb8 template"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad2e569db15494aecaadd2f4a10994cb8">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::n_evaluate</a> (const std::size_t n, const U max)</td></tr>
<tr class="memdesc:gad2e569db15494aecaadd2f4a10994cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of n values that are uniformly contained within range [0, max).  <br /></td></tr>
<tr class="memitem:ga3a3b756d83d04d3e97e50821ab2b6a0a" id="r_ga3a3b756d83d04d3e97e50821ab2b6a0a"><td class="memTemplParams" colspan="2">template&lt;typename T, typename U = T&gt; <br />
requires std::is_arithmetic_v&lt;T&gt; &amp;&amp; std::is_arithmetic_v&lt;U&gt;</td></tr>
<tr class="memitem:ga3a3b756d83d04d3e97e50821ab2b6a0a template"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3a3b756d83d04d3e97e50821ab2b6a0a">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::n_evaluate</a> (const std::vector&lt; U &gt; &amp;max)</td></tr>
<tr class="memdesc:ga3a3b756d83d04d3e97e50821ab2b6a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of max.size() values in range [0; max[i]).  <br /></td></tr>
<tr class="memitem:gab6e7d519beb865b4f0919e8926fcd35e" id="r_gab6e7d519beb865b4f0919e8926fcd35e"><td class="memTemplParams" colspan="2">template&lt;typename T, typename U = T, typename V = U&gt; <br />
requires std::is_arithmetic_v&lt;T&gt; &amp;&amp; std::is_arithmetic_v&lt;U&gt; &amp;&amp; std::is_arithmetic_v&lt;V&gt;</td></tr>
<tr class="memitem:gab6e7d519beb865b4f0919e8926fcd35e template"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab6e7d519beb865b4f0919e8926fcd35e">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::n_evaluate</a> (const std::vector&lt; U &gt; &amp;min, const std::vector&lt; V &gt; &amp;max)</td></tr>
<tr class="memdesc:gab6e7d519beb865b4f0919e8926fcd35e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of n values in range [min[i]; max[i]).  <br /></td></tr>
<tr class="memitem:gad77526d9f07ed2d7ca96ff47bd4ebda2" id="r_gad77526d9f07ed2d7ca96ff47bd4ebda2"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad77526d9f07ed2d7ca96ff47bd4ebda2">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::normalvariate</a> ()</td></tr>
<tr class="memdesc:gad77526d9f07ed2d7ca96ff47bd4ebda2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normal distribution (mean=0.0, stdev=1.0).  <br /></td></tr>
<tr class="memitem:gafe36a7b2090bdb7d075b8eb83397a64b" id="r_gafe36a7b2090bdb7d075b8eb83397a64b"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafe36a7b2090bdb7d075b8eb83397a64b">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::normalvariate</a> (const double mu, const double sigma)</td></tr>
<tr class="memdesc:gafe36a7b2090bdb7d075b8eb83397a64b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normal distribution (mean=mu, stdev=sigma).  <br /></td></tr>
<tr class="memitem:ga4349e1bc8f006808a75fc4a92600f601" id="r_ga4349e1bc8f006808a75fc4a92600f601"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; <br />
requires std::is_arithmetic_v&lt;T&gt;</td></tr>
<tr class="memitem:ga4349e1bc8f006808a75fc4a92600f601 template"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4349e1bc8f006808a75fc4a92600f601">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::operator()</a> (const std::vector&lt; T &gt; &amp;max)</td></tr>
<tr class="memdesc:ga4349e1bc8f006808a75fc4a92600f601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Valued call operator (1 std::vector of scalars).  <br /></td></tr>
<tr class="memitem:ga5ad7362cdb71f98daf788568308efc85" id="r_ga5ad7362cdb71f98daf788568308efc85"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; <br />
requires std::is_arithmetic_v&lt;T&gt;</td></tr>
<tr class="memitem:ga5ad7362cdb71f98daf788568308efc85 template"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5ad7362cdb71f98daf788568308efc85">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::operator()</a> (const std::vector&lt; T &gt; &amp;min, const std::vector&lt; T &gt; &amp;max) noexcept</td></tr>
<tr class="memdesc:ga5ad7362cdb71f98daf788568308efc85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Valued call operator (2 std::vector of scalars).  <br /></td></tr>
<tr class="memitem:ga2db32c9eaadf2a8fb42e325054e825d1" id="r_ga2db32c9eaadf2a8fb42e325054e825d1"><td class="memTemplParams" colspan="2">template&lt;typename T = OutputT&gt; <br />
requires std::is_arithmetic_v&lt;T&gt;</td></tr>
<tr class="memitem:ga2db32c9eaadf2a8fb42e325054e825d1 template"><td class="memItemLeft" align="right" valign="top">const T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2db32c9eaadf2a8fb42e325054e825d1">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::operator()</a> (const T max) noexcept</td></tr>
<tr class="memdesc:ga2db32c9eaadf2a8fb42e325054e825d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Valued call operator (1 scalar).  <br /></td></tr>
<tr class="memitem:gac0a4f78d80b39e6182298266c9e50ce7" id="r_gac0a4f78d80b39e6182298266c9e50ce7"><td class="memTemplParams" colspan="2">template&lt;typename T = OutputT&gt; <br />
requires std::is_arithmetic_v&lt;T&gt;</td></tr>
<tr class="memitem:gac0a4f78d80b39e6182298266c9e50ce7 template"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac0a4f78d80b39e6182298266c9e50ce7">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::operator()</a> (const T max, const std::size_t n)</td></tr>
<tr class="memdesc:gac0a4f78d80b39e6182298266c9e50ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Valued call operator (max and n scalars).  <br /></td></tr>
<tr class="memitem:ga0cff174221c75a002099d2ce9246ae84" id="r_ga0cff174221c75a002099d2ce9246ae84"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; <br />
requires std::is_arithmetic_v&lt;T&gt;</td></tr>
<tr class="memitem:ga0cff174221c75a002099d2ce9246ae84 template"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0cff174221c75a002099d2ce9246ae84">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::operator()</a> (const T min, const T max, const std::size_t n)</td></tr>
<tr class="memdesc:ga0cff174221c75a002099d2ce9246ae84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Valued call operator (min, max and n scalars).  <br /></td></tr>
<tr class="memitem:gadbc667bf6cdca6c744390aa48f4f0de2" id="r_gadbc667bf6cdca6c744390aa48f4f0de2"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadbc667bf6cdca6c744390aa48f4f0de2">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::paretovariate</a> (const double alpha)</td></tr>
<tr class="memdesc:gadbc667bf6cdca6c744390aa48f4f0de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pareto distribution.  <br /></td></tr>
<tr class="memitem:gae089b6fbf9fb202e2c629f81571d196f" id="r_gae089b6fbf9fb202e2c629f81571d196f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae089b6fbf9fb202e2c629f81571d196f">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::randbytes</a> (const std::size_t n)</td></tr>
<tr class="memdesc:gae089b6fbf9fb202e2c629f81571d196f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates n random bytes.  <br /></td></tr>
<tr class="memitem:ga8439b06864112e2ca8604d965d7e475f" id="r_ga8439b06864112e2ca8604d965d7e475f"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; <br />
requires std::is_integral_v&lt;T&gt;</td></tr>
<tr class="memitem:ga8439b06864112e2ca8604d965d7e475f template"><td class="memItemLeft" align="right" valign="top">const T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8439b06864112e2ca8604d965d7e475f">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::randint</a> (const T a, const T b) noexcept</td></tr>
<tr class="memdesc:ga8439b06864112e2ca8604d965d7e475f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random integer in range [a, b], including both end points.  <br /></td></tr>
<tr class="memitem:ga11b942e7b178cf7fe5ab5680b8ca9687" id="r_ga11b942e7b178cf7fe5ab5680b8ca9687"><td class="memTemplParams" colspan="2">template&lt;typename T, typename S = T&gt; <br />
requires std::is_arithmetic_v&lt;T&gt; &amp;&amp; std::is_arithmetic_v&lt;S&gt;</td></tr>
<tr class="memitem:ga11b942e7b178cf7fe5ab5680b8ca9687 template"><td class="memItemLeft" align="right" valign="top">const T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga11b942e7b178cf7fe5ab5680b8ca9687">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::randrange</a> (const T start, const T stop, const S step=S(1))</td></tr>
<tr class="memdesc:ga11b942e7b178cf7fe5ab5680b8ca9687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random value in range [start, stop) with specified step.  <br /></td></tr>
<tr class="memitem:gaaaf19e546c65ac5ebc52d46034914277" id="r_gaaaf19e546c65ac5ebc52d46034914277"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; <br />
requires std::is_integral_v&lt;OutputT&gt; || std::is_same_v&lt;OutputT, <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a>&gt;</td></tr>
<tr class="memitem:gaaaf19e546c65ac5ebc52d46034914277 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaaaf19e546c65ac5ebc52d46034914277">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::sample</a> (std::vector&lt; T &gt; &amp;out, const std::vector&lt; T &gt; &amp;population, const std::size_t k)</td></tr>
<tr class="memdesc:gaaaf19e546c65ac5ebc52d46034914277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chooses k unique random elements from a population sequence. All population elements have same weight for the sampling and are each chosen only once.  <br /></td></tr>
<tr class="memitem:gae7627aeb3d6c10d723dbb2845056fe1c" id="r_gae7627aeb3d6c10d723dbb2845056fe1c"><td class="memTemplParams" colspan="2">template&lt;typename T, typename C&gt; <br />
requires std::is_integral_v&lt;C&gt;</td></tr>
<tr class="memitem:gae7627aeb3d6c10d723dbb2845056fe1c template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae7627aeb3d6c10d723dbb2845056fe1c">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::sample</a> (std::vector&lt; T &gt; &amp;out, const std::vector&lt; T &gt; &amp;population, const std::vector&lt; C &gt; &amp;counts, const std::size_t k)</td></tr>
<tr class="memdesc:gae7627aeb3d6c10d723dbb2845056fe1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chooses k unique random elements from a population sequence (std::vector&lt;&gt;, with counts vector).  <br /></td></tr>
<tr class="memitem:gaf50658949f3ac03f10639ef4eec8cae7" id="r_gaf50658949f3ac03f10639ef4eec8cae7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf50658949f3ac03f10639ef4eec8cae7">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::seed</a> () noexcept</td></tr>
<tr class="memdesc:gaf50658949f3ac03f10639ef4eec8cae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes internal state (empty signature).  <br /></td></tr>
<tr class="memitem:gac8106d037d8f18e17901d5b8c4632863" id="r_gac8106d037d8f18e17901d5b8c4632863"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac8106d037d8f18e17901d5b8c4632863">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::seed</a> (const double seed_)</td></tr>
<tr class="memdesc:gac8106d037d8f18e17901d5b8c4632863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initalizes internal state from a double seed.  <br /></td></tr>
<tr class="memitem:ga88b7e4afc3516140ee5d6721c6ec1212" id="r_ga88b7e4afc3516140ee5d6721c6ec1212"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga88b7e4afc3516140ee5d6721c6ec1212">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::seed</a> (const int seed_) noexcept</td></tr>
<tr class="memdesc:ga88b7e4afc3516140ee5d6721c6ec1212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes internal state from a 32-bits signed integer seed.  <br /></td></tr>
<tr class="memitem:ga387834ddb1430f92cf5c5976fba95257" id="r_ga387834ddb1430f92cf5c5976fba95257"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga387834ddb1430f92cf5c5976fba95257">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::seed</a> (const long long seed_) noexcept</td></tr>
<tr class="memdesc:ga387834ddb1430f92cf5c5976fba95257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes internal state from a 64-bits unsigned integer seed.  <br /></td></tr>
<tr class="memitem:gaf7d908c937f886baaa7624313a62cfb9" id="r_gaf7d908c937f886baaa7624313a62cfb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf7d908c937f886baaa7624313a62cfb9">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::seed</a> (const long seed_) noexcept</td></tr>
<tr class="memdesc:gaf7d908c937f886baaa7624313a62cfb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes internal state from a 32-bits unsigned integer seed.  <br /></td></tr>
<tr class="memitem:ga2d2460b994956f0e4ecac473d2055024" id="r_ga2d2460b994956f0e4ecac473d2055024"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2d2460b994956f0e4ecac473d2055024">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::seed</a> (const unsigned int seed_) noexcept</td></tr>
<tr class="memdesc:ga2d2460b994956f0e4ecac473d2055024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes internal state from a 32-bits unsigned integer seed.  <br /></td></tr>
<tr class="memitem:gadc6434f1f216d9ba2d936c8d671e7d3e" id="r_gadc6434f1f216d9ba2d936c8d671e7d3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadc6434f1f216d9ba2d936c8d671e7d3e">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::seed</a> (const unsigned long long seed_) noexcept</td></tr>
<tr class="memdesc:gadc6434f1f216d9ba2d936c8d671e7d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes internal state from a 64-bits unsigned integer seed.  <br /></td></tr>
<tr class="memitem:gae3ec11e03404f276381459e668dedddd" id="r_gae3ec11e03404f276381459e668dedddd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae3ec11e03404f276381459e668dedddd">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::seed</a> (const unsigned long seed_) noexcept</td></tr>
<tr class="memdesc:gae3ec11e03404f276381459e668dedddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes internal state from a 32-bits unsigned integer seed.  <br /></td></tr>
<tr class="memitem:ga00b4ca2ee21072e6cdd4f3f850608375" id="r_ga00b4ca2ee21072e6cdd4f3f850608375"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga00b4ca2ee21072e6cdd4f3f850608375">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::seed</a> (const <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a> &amp;seed_) noexcept</td></tr>
<tr class="memdesc:ga00b4ca2ee21072e6cdd4f3f850608375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the internal state of this PRNG with a 128-bits integer seed.  <br /></td></tr>
<tr class="memitem:gafb899e92eb6b4ae2217ba2d4b96b7fec" id="r_gafb899e92eb6b4ae2217ba2d4b96b7fec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafb899e92eb6b4ae2217ba2d4b96b7fec">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::setstate</a> (const StateT &amp;new_internal_state) noexcept</td></tr>
<tr class="memdesc:gafb899e92eb6b4ae2217ba2d4b96b7fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the internal state from a new internal state content.  <br /></td></tr>
<tr class="memitem:ga56920e73800fd5a1e689e490a5cb21c2" id="r_ga56920e73800fd5a1e689e490a5cb21c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga56920e73800fd5a1e689e490a5cb21c2">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::setstate</a> (const StateT &amp;new_internal_state, const double gauss_next) noexcept</td></tr>
<tr class="memdesc:ga56920e73800fd5a1e689e490a5cb21c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restores internal state from a new internal state content and with gauss_next.  <br /></td></tr>
<tr class="memitem:gabe28727e6672d692f12e8ce98b0d130a" id="r_gabe28727e6672d692f12e8ce98b0d130a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabe28727e6672d692f12e8ce98b0d130a">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::setstate</a> (const struct <a class="el" href="struct_base_random_1_1___internal_state.html">_InternalState</a> &amp;new_internal_state) noexcept</td></tr>
<tr class="memdesc:gabe28727e6672d692f12e8ce98b0d130a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restores internal state from object returned by <a class="el" href="class_base_random.html#ad3504565dc9bd81a27af0e00a27eeb83" title="Returns the internal state of this PRNG; can be later passed to setstate().">getstate()</a>.  <br /></td></tr>
<tr class="memitem:ga3163040e9149d9c50a867e44511c88fe" id="r_ga3163040e9149d9c50a867e44511c88fe"><td class="memTemplParams" colspan="2">template&lt;typename ContainerType&gt; <br />
requires utils::is_indexable_v&lt;ContainerType&gt;</td></tr>
<tr class="memitem:ga3163040e9149d9c50a867e44511c88fe template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3163040e9149d9c50a867e44511c88fe">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::shuffle</a> (ContainerType &amp;seq)</td></tr>
<tr class="memdesc:ga3163040e9149d9c50a867e44511c88fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">In place Shuffles the specified sequence.  <br /></td></tr>
<tr class="memitem:gaeb4a7ee56265e93551bb7e931543e7df" id="r_gaeb4a7ee56265e93551bb7e931543e7df"><td class="memItemLeft" align="right" valign="top">const StateT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaeb4a7ee56265e93551bb7e931543e7df">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::state</a> () const noexcept</td></tr>
<tr class="memdesc:gaeb4a7ee56265e93551bb7e931543e7df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current internal state value.  <br /></td></tr>
<tr class="memitem:ga3b791d56d12aafeb87e425c0e8fe7010" id="r_ga3b791d56d12aafeb87e425c0e8fe7010"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3b791d56d12aafeb87e425c0e8fe7010">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::triangular</a> () noexcept</td></tr>
<tr class="memdesc:ga3b791d56d12aafeb87e425c0e8fe7010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangular distribution (low=0.0, high=1.0, mode=0.5).  <br /></td></tr>
<tr class="memitem:ga55a55b28439200715c1a42d304883422" id="r_ga55a55b28439200715c1a42d304883422"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga55a55b28439200715c1a42d304883422">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::triangular</a> (const double low, const double high) noexcept</td></tr>
<tr class="memdesc:ga55a55b28439200715c1a42d304883422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangular distribution (low, high, default mode).  <br /></td></tr>
<tr class="memitem:gaccf4702117a9d9490a87e00c16d05cef" id="r_gaccf4702117a9d9490a87e00c16d05cef"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaccf4702117a9d9490a87e00c16d05cef">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::triangular</a> (const double low, const double high, const double mode) noexcept</td></tr>
<tr class="memdesc:gaccf4702117a9d9490a87e00c16d05cef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangular distribution (low, high, mode).  <br /></td></tr>
<tr class="memitem:ga3c08475e886d4f45f706ac4509a907d8" id="r_ga3c08475e886d4f45f706ac4509a907d8"><td class="memTemplParams" colspan="2">template&lt;typename T = double&gt; <br />
requires std::is_floating_point_v&lt;T&gt;</td></tr>
<tr class="memitem:ga3c08475e886d4f45f706ac4509a907d8 template"><td class="memItemLeft" align="right" valign="top">const T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3c08475e886d4f45f706ac4509a907d8">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::uniform</a> () noexcept</td></tr>
<tr class="memdesc:ga3c08475e886d4f45f706ac4509a907d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uniform distribution in [0.0, 1.0).  <br /></td></tr>
<tr class="memitem:ga2f1713879cb60593098161cc84a3f164" id="r_ga2f1713879cb60593098161cc84a3f164"><td class="memTemplParams" colspan="2">template&lt;typename T = double, typename U = T&gt; <br />
requires std::is_arithmetic_v&lt;T&gt; &amp;&amp; std::is_arithmetic_v&lt;U&gt;</td></tr>
<tr class="memitem:ga2f1713879cb60593098161cc84a3f164 template"><td class="memItemLeft" align="right" valign="top">const T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2f1713879cb60593098161cc84a3f164">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::uniform</a> (const U max) noexcept</td></tr>
<tr class="memdesc:ga2f1713879cb60593098161cc84a3f164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uniform distribution [0.0, max).  <br /></td></tr>
<tr class="memitem:gaa4fc4c76e0b02e6aed29297b579687c9" id="r_gaa4fc4c76e0b02e6aed29297b579687c9"><td class="memTemplParams" colspan="2">template&lt;typename T, typename U = T, typename V = U&gt; <br />
requires std::is_arithmetic_v&lt;T&gt; &amp;&amp; std::is_arithmetic_v&lt;U&gt; &amp;&amp; std::is_arithmetic_v&lt;V&gt;</td></tr>
<tr class="memitem:gaa4fc4c76e0b02e6aed29297b579687c9 template"><td class="memItemLeft" align="right" valign="top">const T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa4fc4c76e0b02e6aed29297b579687c9">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::uniform</a> (const U min, const V max) noexcept</td></tr>
<tr class="memdesc:gaa4fc4c76e0b02e6aed29297b579687c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uniform distribution in [min, max).  <br /></td></tr>
<tr class="memitem:ga15a53c095b66916ce70a91b0c1772498" id="r_ga15a53c095b66916ce70a91b0c1772498"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga15a53c095b66916ce70a91b0c1772498">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::vonmisesvariate</a> (const double mu, const double kappa)</td></tr>
<tr class="memdesc:ga15a53c095b66916ce70a91b0c1772498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Circular data distribution.  <br /></td></tr>
<tr class="memitem:gab860b1b1b792c32efe3ad1f16eab254c" id="r_gab860b1b1b792c32efe3ad1f16eab254c"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab860b1b1b792c32efe3ad1f16eab254c">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::weibullvariate</a> (const double alpha, const double beta)</td></tr>
<tr class="memdesc:gab860b1b1b792c32efe3ad1f16eab254c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weibull distribution.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga1b1379b01a36be483ca9b7c922c22a27" id="r_ga1b1379b01a36be483ca9b7c922c22a27"><td class="memTemplParams" colspan="2"><a id="ga1b1379b01a36be483ca9b7c922c22a27" name="ga1b1379b01a36be483ca9b7c922c22a27"></a>
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </td></tr>
<tr class="memitem:ga1b1379b01a36be483ca9b7c922c22a27 template"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><b>BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::E</b> { std::exp(1.0) }</td></tr>
<tr class="memitem:ga8aba9709768420d2e1f6818e45ce7b81" id="r_ga8aba9709768420d2e1f6818e45ce7b81"><td class="memTemplParams" colspan="2"><a id="ga8aba9709768420d2e1f6818e45ce7b81" name="ga8aba9709768420d2e1f6818e45ce7b81"></a>
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </td></tr>
<tr class="memitem:ga8aba9709768420d2e1f6818e45ce7b81 template"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><b>BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::LOG4</b> { std::log(4.0) }</td></tr>
<tr class="memitem:gafa9c044d636b93b9c92ec534081bca30" id="r_gafa9c044d636b93b9c92ec534081bca30"><td class="memTemplParams" colspan="2"><a id="gafa9c044d636b93b9c92ec534081bca30" name="gafa9c044d636b93b9c92ec534081bca30"></a>
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </td></tr>
<tr class="memitem:gafa9c044d636b93b9c92ec534081bca30 template"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><b>BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::NV_MAGICCONST</b> { 4 * std::exp(-0.5) / std::sqrt(2.0) }</td></tr>
<tr class="memitem:ga30c2bc68148b3587db28f4558cbbb05d" id="r_ga30c2bc68148b3587db28f4558cbbb05d"><td class="memTemplParams" colspan="2"><a id="ga30c2bc68148b3587db28f4558cbbb05d" name="ga30c2bc68148b3587db28f4558cbbb05d"></a>
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </td></tr>
<tr class="memitem:ga30c2bc68148b3587db28f4558cbbb05d template"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><b>BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::RECIP_BPF</b> { std::exp2(-BPF) }</td></tr>
<tr class="memitem:gad7560b1892cf36741c258e7a13b68179" id="r_gad7560b1892cf36741c258e7a13b68179"><td class="memTemplParams" colspan="2"><a id="gad7560b1892cf36741c258e7a13b68179" name="gad7560b1892cf36741c258e7a13b68179"></a>
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </td></tr>
<tr class="memitem:gad7560b1892cf36741c258e7a13b68179 template"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><b>BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::SG_MAGICCONST</b> { 1.0 + std::log(4.5) }</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<p>This is the definition of the base class for all pseudo-random numbers generators that are implemented in CppRandLib. </p>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="gad247a2374d091a20d7b668474e89e6c4" name="gad247a2374d091a20d7b668474e89e6c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad247a2374d091a20d7b668474e89e6c4">&#9670;&#160;</a></span>betavariate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_integral_v&lt;OutputT&gt; || std::is_same_v&lt;OutputT, <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a>&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">const double <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::betavariate </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Beta distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>double, must be greater than 0 </td></tr>
    <tr><td class="paramname">beta</td><td>double, must be greater than 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a value in range [0.0, 1.0].</dd></dl>
<p>Important notice: the implemented code is a translation from Python <a href="https://github.com/python/cpython/blob/3.11/Lib/random.py">https://github.com/python/cpython/blob/3.11/Lib/random.py</a> into c++. The original code is due to Janne Sinkkonen and matches all the std texts (e.g., Knuth Vol 2 Ed 3 pg 134 "the beta distribution").</p>
<p>Beta distribution. </p>

<p class="reference">References <a class="el" href="#ga936e58e8231d9194bf32d9338999bff4">gammavariate()</a>.</p>

</div>
</div>
<a id="gae9e46564b6f810a9cf529c8b5349727a" name="gae9e46564b6f810a9cf529c8b5349727a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9e46564b6f810a9cf529c8b5349727a">&#9670;&#160;</a></span>binomialvariate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_integral_v&lt;CountT&gt;&amp;&amp; std::is_floating_point_v&lt;ProbaT&gt;</div>
<div class="memtemplate">
template&lt;typename CountT, typename ProbaT&gt; <br />
requires std::is_integral_v&lt;CountT&gt;&amp;&amp; std::is_floating_point_v&lt;ProbaT&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">const CountT <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::binomialvariate </td>
          <td>(</td>
          <td class="paramtype">const CountT</td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ProbaT</td>          <td class="paramname"><span class="paramname"><em>p</em></span><span class="paramdefsep"> = </span><span class="paramdefval">ProbaT(0.5)</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of successes for n&gt;=0 independent trials. </p>
<p>Returns the number of successes for n&gt;=0 independent trials. </p>

<p class="reference">References <a class="el" href="#ga3c08475e886d4f45f706ac4509a907d8">uniform()</a>.</p>

</div>
</div>
<a id="gae81fe65366b54ec3a9b2975860ce75b3" name="gae81fe65366b54ec3a9b2975860ce75b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae81fe65366b54ec3a9b2975860ce75b3">&#9670;&#160;</a></span>choice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_integral_v&lt;OutputT&gt; || std::is_same_v&lt;OutputT, <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a>&gt;</div>
<div class="memtemplate">
template&lt;typename T&gt; <br />
requires std::is_integral_v&lt;OutputT&gt; || std::is_same_v&lt;OutputT, <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a>&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::choice </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>seq</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chooses a random element from a non-empty sequence (std::vector). </p>
<p>Chooses a random element from a non-empty sequence (std::vector). </p>

<p class="reference">References <a class="el" href="#ga3c08475e886d4f45f706ac4509a907d8">uniform()</a>.</p>

</div>
</div>
<a id="gabbfd6e6e55f9f53ee50e7529ddae3eba" name="gabbfd6e6e55f9f53ee50e7529ddae3eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbfd6e6e55f9f53ee50e7529ddae3eba">&#9670;&#160;</a></span>choices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_integral_v&lt;OutputT&gt; || std::is_same_v&lt;OutputT, <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a>&gt;</div>
<div class="memtemplate">
template&lt;typename T&gt; <br />
requires std::is_integral_v&lt;OutputT&gt; || std::is_same_v&lt;OutputT, <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a>&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::choices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>population</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>k</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a k sized vector of elements chosen from the population with replacement (same weights). </p>
<p>Returns a k sized vector of elements chosen from the population with replacement (same weights). </p>

<p class="reference">References <a class="el" href="#ga1889ab84371fc977b0e9816665e17231">choices_cum()</a>.</p>

</div>
</div>
<a id="ga23f2f44f6b507dd36b9731242312a6f2" name="ga23f2f44f6b507dd36b9731242312a6f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23f2f44f6b507dd36b9731242312a6f2">&#9670;&#160;</a></span>choices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_arithmetic_v&lt;C&gt;</div>
<div class="memtemplate">
template&lt;typename T, typename C&gt; <br />
requires std::is_arithmetic_v&lt;C&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::choices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>population</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; C &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>weights</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>k</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a k sized vector of elements chosen from the population with replacement (individual weights). </p>
<p>Returns a k sized vector of elements chosen from the population with replacement (individual weights). </p>

<p class="reference">References <a class="el" href="#ga1889ab84371fc977b0e9816665e17231">choices_cum()</a>.</p>

</div>
</div>
<a id="ga1889ab84371fc977b0e9816665e17231" name="ga1889ab84371fc977b0e9816665e17231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1889ab84371fc977b0e9816665e17231">&#9670;&#160;</a></span>choices_cum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_arithmetic_v&lt;C&gt;</div>
<div class="memtemplate">
template&lt;typename T, typename C&gt; <br />
requires std::is_arithmetic_v&lt;C&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::choices_cum </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>population</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; C &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cum_weights</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>k</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a k sized vector of elements chosen from the population with replacement (cumulative weights). </p>
<p>Returns a k sized vector of elements chosen from the population with replacement (cumulative weights). </p>

<p class="reference">References <a class="el" href="#ga3c08475e886d4f45f706ac4509a907d8">uniform()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#gabbfd6e6e55f9f53ee50e7529ddae3eba">choices()</a>, and <a class="el" href="#ga23f2f44f6b507dd36b9731242312a6f2">choices()</a>.</p>

</div>
</div>
<a id="gad6d05022f14a2c7c07a069f8bfec1726" name="gad6d05022f14a2c7c07a069f8bfec1726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6d05022f14a2c7c07a069f8bfec1726">&#9670;&#160;</a></span>expovariate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_integral_v&lt;OutputT&gt; || std::is_same_v&lt;OutputT, <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a>&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">const double <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::expovariate </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>lambda</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exponential distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lambda</td><td>double, this should get the value (1.0 / desired_mean). It cannot be 0.0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a value in range [0.0, Infinity) if lambda is positive, or a value in range (-Infinity, 0.0] if lambda is negative.</dd></dl>
<p>Important notice: the implemented code is a translation from Python <a href="https://github.com/python/cpython/blob/3.11/Lib/random.py">https://github.com/python/cpython/blob/3.11/Lib/random.py</a> into c++.</p>
<p>Exponential distribution. </p>

<p class="reference">References <a class="el" href="#ga3c08475e886d4f45f706ac4509a907d8">uniform()</a>.</p>

</div>
</div>
<a id="ga936e58e8231d9194bf32d9338999bff4" name="ga936e58e8231d9194bf32d9338999bff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga936e58e8231d9194bf32d9338999bff4">&#9670;&#160;</a></span>gammavariate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_integral_v&lt;OutputT&gt; || std::is_same_v&lt;OutputT, <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a>&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">const double <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::gammavariate </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gamma distribution. This is NOT the gamma function! </p>
<p>The probability distribution function is : x^(alpha - 1) * std::exp(-x / beta) pdf(x) = --------------------------------&mdash; std::tgamma(alpha) * beta^alpha where: pdf is the probability density function a^b is std::pow(a, b) std::tgamma() is the Gamma funtion as implemented in the c++ math library.</p>
<p>The Gamma function is the below integral summation from 0 to Infinity: Γ(x) = ∫0∞ t^(x−1) * std::exp(−t) dt</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>: double, the shape parameter - must be greater than 0.0. </td></tr>
    <tr><td class="paramname">beta</td><td>: double, the scale parameter - must be greater than 0.0. With these two arguments: mean is alpha * beta and variance is alpha * beta * beta</td></tr>
  </table>
  </dd>
</dl>
<p>Important notice: the implemented code is a translation from Python <a href="https://github.com/python/cpython/blob/3.11/Lib/random.py">https://github.com/python/cpython/blob/3.11/Lib/random.py</a> into c++. As such, some comments present in the Python original code have been copied as is in this c++ implementation, naming then the authors of the related parts of code.</p>
<p>Gamma distribution. This is NOT the gamma function! </p>

<p class="reference">References <a class="el" href="#ga3c08475e886d4f45f706ac4509a907d8">uniform()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#gad247a2374d091a20d7b668474e89e6c4">betavariate()</a>.</p>

</div>
</div>
<a id="ga3638eab8f6adf1da44e9e1d18b69145f" name="ga3638eab8f6adf1da44e9e1d18b69145f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3638eab8f6adf1da44e9e1d18b69145f">&#9670;&#160;</a></span>gauss() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_integral_v&lt;OutputT&gt; || std::is_same_v&lt;OutputT, <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a>&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::gauss </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default Gaussian distribution (mean=0.0, stdev=1.0). </p>
<p>This is slightly faster than the <a class="el" href="#gad77526d9f07ed2d7ca96ff47bd4ebda2" title="Normal distribution (mean=0.0, stdev=1.0).">normalvariate()</a> function. Notice: not thread-safe without a lock around calls.</p>
<p>Important notice: the implemented code is a translation from Python <a href="https://github.com/python/cpython/blob/3.11/Lib/random.py">https://github.com/python/cpython/blob/3.11/Lib/random.py</a> into c++.</p>
<p>Default Gaussian distribution (mean=0.0, stdev=1.0). </p>

<p class="reference">References <a class="el" href="#ga3638eab8f6adf1da44e9e1d18b69145f">gauss()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#ga3638eab8f6adf1da44e9e1d18b69145f">gauss()</a>.</p>

</div>
</div>
<a id="ga3f118338c6e34fb76adb2343edfd3ace" name="ga3f118338c6e34fb76adb2343edfd3ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f118338c6e34fb76adb2343edfd3ace">&#9670;&#160;</a></span>gauss() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_integral_v&lt;OutputT&gt; || std::is_same_v&lt;OutputT, <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a>&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">const double <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::gauss </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>mu</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>sigma</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gaussian distribution (mean=mu, stdev=sigma). </p>
<p>mu is the mean, and sigma is the standard deviation. mu can be any value, sigma must be greater than 0.0. This is slightly faster than the <a class="el" href="#gad77526d9f07ed2d7ca96ff47bd4ebda2" title="Normal distribution (mean=0.0, stdev=1.0).">normalvariate()</a> function.</p>
<p>Notice: not thread-safe without a mutex around calls.</p>
<p>Important notice: the implemented code is a translation from Python <a href="https://github.com/python/cpython/blob/3.11/Lib/random.py">https://github.com/python/cpython/blob/3.11/Lib/random.py</a> into c++.</p>
<p>Gaussian distribution (mean=mu, stdev=sigma). </p>

<p class="reference">References <a class="el" href="#ga3c08475e886d4f45f706ac4509a907d8">uniform()</a>.</p>

</div>
</div>
<a id="ga61460bcb665bc5c7ac684d272ff34c99" name="ga61460bcb665bc5c7ac684d272ff34c99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61460bcb665bc5c7ac684d272ff34c99">&#9670;&#160;</a></span>lognormvariate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_integral_v&lt;OutputT&gt; || std::is_same_v&lt;OutputT, <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a>&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::lognormvariate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default Log normal distribution (mean=0.0, stdev=1.0). </p>
<p>If you take the natural logarithm of this distribution, you'll get a normal distribution with mean 0.0 and standard deviation 1.0.</p>
<p>Important notice: the implemented code is a translation from Python <a href="https://github.com/python/cpython/blob/3.11/Lib/random.py">https://github.com/python/cpython/blob/3.11/Lib/random.py</a> into c++.</p>
<p>Default Log normal distribution (mean=0.0, stdev=1.0). </p>

<p class="reference">References <a class="el" href="#ga61460bcb665bc5c7ac684d272ff34c99">lognormvariate()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#ga61460bcb665bc5c7ac684d272ff34c99">lognormvariate()</a>.</p>

</div>
</div>
<a id="gaac53fbbe5df64d8471764b650c4c9612" name="gaac53fbbe5df64d8471764b650c4c9612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac53fbbe5df64d8471764b650c4c9612">&#9670;&#160;</a></span>lognormvariate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_integral_v&lt;OutputT&gt; || std::is_same_v&lt;OutputT, <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a>&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::lognormvariate </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>mu</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>sigma</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Log normal distribution (mean=mu, stdev=sigma). </p>
<p>If you take the natural logarithm of this distribution, you'll get a normal distribution with mean mu and standard deviation sigma. mu can have any value, and sigma must be greater than zero.</p>
<p>Important notice: the implemented code is a translation from Python <a href="https://github.com/python/cpython/blob/3.11/Lib/random.py">https://github.com/python/cpython/blob/3.11/Lib/random.py</a> into c++.</p>
<p>Log normal distribution (mean=mu, stdev=sigma). </p>

<p class="reference">References <a class="el" href="#gad77526d9f07ed2d7ca96ff47bd4ebda2">normalvariate()</a>.</p>

</div>
</div>
<a id="gaa1658d6f0081d7d78e0816a9e4b80b16" name="gaa1658d6f0081d7d78e0816a9e4b80b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1658d6f0081d7d78e0816a9e4b80b16">&#9670;&#160;</a></span>n_evaluate() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_floating_point_v&lt;T&gt;</div>
<div class="memtemplate">
template&lt;typename T&gt; <br />
requires std::is_floating_point_v&lt;T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::n_evaluate </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector of n values that are uniformly contained within range [0.0, 1.0). </p>
<p>Returns a vector of n values that are uniformly contained within range [0.0, 1.0). </p>

</div>
</div>
<a id="gad2e569db15494aecaadd2f4a10994cb8" name="gad2e569db15494aecaadd2f4a10994cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2e569db15494aecaadd2f4a10994cb8">&#9670;&#160;</a></span>n_evaluate() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_arithmetic_v&lt;T&gt; &amp;&amp; std::is_arithmetic_v&lt;U&gt;</div>
<div class="memtemplate">
template&lt;typename T, typename U&gt; <br />
requires std::is_arithmetic_v&lt;T&gt; &amp;&amp; std::is_arithmetic_v&lt;U&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::n_evaluate </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>max</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of n values that are uniformly contained within range [0, max). </p>
<p>Returns a vector of n values that are uniformly contained within range [0, max). </p>

<p class="reference">References <a class="el" href="#ga3c08475e886d4f45f706ac4509a907d8">uniform()</a>.</p>

</div>
</div>
<a id="ga3a3b756d83d04d3e97e50821ab2b6a0a" name="ga3a3b756d83d04d3e97e50821ab2b6a0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a3b756d83d04d3e97e50821ab2b6a0a">&#9670;&#160;</a></span>n_evaluate() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_arithmetic_v&lt;T&gt; &amp;&amp; std::is_arithmetic_v&lt;U&gt;</div>
<div class="memtemplate">
template&lt;typename T, typename U&gt; <br />
requires std::is_arithmetic_v&lt;T&gt; &amp;&amp; std::is_arithmetic_v&lt;U&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::n_evaluate </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>max</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of max.size() values in range [0; max[i]). </p>
<p>Returns a vector of n values in range [0; max[i]). </p>

<p class="reference">References <a class="el" href="#ga3c08475e886d4f45f706ac4509a907d8">uniform()</a>.</p>

</div>
</div>
<a id="gab6e7d519beb865b4f0919e8926fcd35e" name="gab6e7d519beb865b4f0919e8926fcd35e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6e7d519beb865b4f0919e8926fcd35e">&#9670;&#160;</a></span>n_evaluate() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_arithmetic_v&lt;T&gt; &amp;&amp; std::is_arithmetic_v&lt;U&gt; &amp;&amp; std::is_arithmetic_v&lt;V&gt;</div>
<div class="memtemplate">
template&lt;typename T, typename U, typename V&gt; <br />
requires std::is_arithmetic_v&lt;T&gt; &amp;&amp; std::is_arithmetic_v&lt;U&gt; &amp;&amp; std::is_arithmetic_v&lt;V&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::n_evaluate </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; V &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>max</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of n values in range [min[i]; max[i]). </p>
<p>Returns a vector of n values in range [min[i]; max[i]). </p>

<p class="reference">References <a class="el" href="#ga3c08475e886d4f45f706ac4509a907d8">uniform()</a>.</p>

</div>
</div>
<a id="gad77526d9f07ed2d7ca96ff47bd4ebda2" name="gad77526d9f07ed2d7ca96ff47bd4ebda2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad77526d9f07ed2d7ca96ff47bd4ebda2">&#9670;&#160;</a></span>normalvariate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_integral_v&lt;OutputT&gt; || std::is_same_v&lt;OutputT, <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a>&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::normalvariate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normal distribution (mean=0.0, stdev=1.0). </p>
<p>The Python version of this method uses Kindermanand Monahan method. Reference: Kinderman, A.J.and Monahan, J.F., "Computer generation of
random variables using the ratio of  uniform  deviates", ACM Trans Math Software, 3, (1977), pp257 - 260. This method is slightlly slower than the gauss method. Furthermore, we've s lightly modified the original algorithm here to fulfill very special cases that might happen in very specific conditions. This slows down also the running of <a class="el" href="#gad77526d9f07ed2d7ca96ff47bd4ebda2" title="Normal distribution (mean=0.0, stdev=1.0).">normalvariate()</a> in these very specific conditions. You should prefer then to use method <a class="el" href="#ga3638eab8f6adf1da44e9e1d18b69145f" title="Default Gaussian distribution (mean=0.0, stdev=1.0).">gauss()</a> instead of this one.</p>
<p>Important notice: the implemented code is a translation from Python <a href="https://github.com/python/cpython/blob/3.11/Lib/random.py">https://github.com/python/cpython/blob/3.11/Lib/random.py</a> into c++.</p>
<p>Normal distribution (mean=0.0, stdev=1.0). </p>

<p class="reference">References <a class="el" href="#gad77526d9f07ed2d7ca96ff47bd4ebda2">normalvariate()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#gaac53fbbe5df64d8471764b650c4c9612">lognormvariate()</a>, and <a class="el" href="#gad77526d9f07ed2d7ca96ff47bd4ebda2">normalvariate()</a>.</p>

</div>
</div>
<a id="gafe36a7b2090bdb7d075b8eb83397a64b" name="gafe36a7b2090bdb7d075b8eb83397a64b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe36a7b2090bdb7d075b8eb83397a64b">&#9670;&#160;</a></span>normalvariate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_integral_v&lt;OutputT&gt; || std::is_same_v&lt;OutputT, <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a>&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::normalvariate </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>mu</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>sigma</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normal distribution (mean=mu, stdev=sigma). </p>
<p>mu is the mean, and sigma is the standard deviation. mu can be any value, sigma must be greater than 0.0.</p>
<p>The Python version of this method uses Kindermanand Monahan method. Reference: Kinderman, A.J.and Monahan, J.F., "Computer generation of
random variables using the ratio of  uniform  deviates", ACM Trans Math Software, 3, (1977), pp257 - 260. This method is slightlly slower than the gauss method. Furthermore, we've s lightly modified the original algorithm here to fulfill very special cases that might happen in very specific conditions. This slows down also the running of <a class="el" href="#gad77526d9f07ed2d7ca96ff47bd4ebda2" title="Normal distribution (mean=0.0, stdev=1.0).">normalvariate()</a> in these very specific conditions. You should prefer then to use method <a class="el" href="#ga3638eab8f6adf1da44e9e1d18b69145f" title="Default Gaussian distribution (mean=0.0, stdev=1.0).">gauss()</a> instead of this one.</p>
<p>Important notice: the implemented code is a translation from Python <a href="https://github.com/python/cpython/blob/3.11/Lib/random.py">https://github.com/python/cpython/blob/3.11/Lib/random.py</a> into c++.</p>
<p>Normal distribution (mean=mu, stdev=sigma). </p>

<p class="reference">References <a class="el" href="#ga3c08475e886d4f45f706ac4509a907d8">uniform()</a>.</p>

</div>
</div>
<a id="ga4349e1bc8f006808a75fc4a92600f601" name="ga4349e1bc8f006808a75fc4a92600f601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4349e1bc8f006808a75fc4a92600f601">&#9670;&#160;</a></span>operator()() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_arithmetic_v&lt;T&gt;</div>
<div class="memtemplate">
template&lt;typename T&gt; <br />
requires std::is_arithmetic_v&lt;T&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>max</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Valued call operator (1 std::vector of scalars). </p>
<dl class="section return"><dt>Returns</dt><dd>a vector of values that are uniformly contained within the interval [0; max[i]) &ndash; i being the index of the value in the returned vector.</dd></dl>
<p>Valued call operator (1 std::vector of scalars). </p>

<p class="reference">References <a class="el" href="#ga3c08475e886d4f45f706ac4509a907d8">uniform()</a>.</p>

</div>
</div>
<a id="ga5ad7362cdb71f98daf788568308efc85" name="ga5ad7362cdb71f98daf788568308efc85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ad7362cdb71f98daf788568308efc85">&#9670;&#160;</a></span>operator()() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_arithmetic_v&lt;T&gt;</div>
<div class="memtemplate">
template&lt;typename T&gt; <br />
requires std::is_arithmetic_v&lt;T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>max</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Valued call operator (2 std::vector of scalars). </p>
<dl class="section return"><dt>Returns</dt><dd>a vector of values that are uniformly contained within the range [min[i]; max[i]), i being the index of the value in the returned vector.</dd></dl>
<p>Valued call operator (2 std::vector of scalars). </p>

<p class="reference">References <a class="el" href="#ga3c08475e886d4f45f706ac4509a907d8">uniform()</a>.</p>

</div>
</div>
<a id="ga2db32c9eaadf2a8fb42e325054e825d1" name="ga2db32c9eaadf2a8fb42e325054e825d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2db32c9eaadf2a8fb42e325054e825d1">&#9670;&#160;</a></span>operator()() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_arithmetic_v&lt;T&gt;</div>
<div class="memtemplate">
template&lt;typename T&gt; <br />
requires std::is_arithmetic_v&lt;T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>max</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Valued call operator (1 scalar). </p>
<dl class="section return"><dt>Returns</dt><dd>a value that is uniformly contained within range [0; max).</dd></dl>
<p>Valued call operator (1 scalar). </p>

<p class="reference">References <a class="el" href="#ga3c08475e886d4f45f706ac4509a907d8">uniform()</a>.</p>

</div>
</div>
<a id="gac0a4f78d80b39e6182298266c9e50ce7" name="gac0a4f78d80b39e6182298266c9e50ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0a4f78d80b39e6182298266c9e50ce7">&#9670;&#160;</a></span>operator()() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_arithmetic_v&lt;T&gt;</div>
<div class="memtemplate">
template&lt;typename T&gt; <br />
requires std::is_arithmetic_v&lt;T&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>max</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Valued call operator (max and n scalars). </p>
<dl class="section return"><dt>Returns</dt><dd>a value that is uniformly contained within range [min; max).</dd></dl>
<p>Valued call operator (max and n scalars). </p>

<p class="reference">References <a class="el" href="#ga3c08475e886d4f45f706ac4509a907d8">uniform()</a>.</p>

</div>
</div>
<a id="ga0cff174221c75a002099d2ce9246ae84" name="ga0cff174221c75a002099d2ce9246ae84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cff174221c75a002099d2ce9246ae84">&#9670;&#160;</a></span>operator()() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_arithmetic_v&lt;T&gt;</div>
<div class="memtemplate">
template&lt;typename T&gt; <br />
requires std::is_arithmetic_v&lt;T&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>max</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Valued call operator (min, max and n scalars). </p>
<dl class="section return"><dt>Returns</dt><dd>a value that is uniformly contained within range [min; max).</dd></dl>
<p>Valued call operator (min, max and n scalars). </p>

<p class="reference">References <a class="el" href="#ga3c08475e886d4f45f706ac4509a907d8">uniform()</a>.</p>

</div>
</div>
<a id="gadbc667bf6cdca6c744390aa48f4f0de2" name="gadbc667bf6cdca6c744390aa48f4f0de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbc667bf6cdca6c744390aa48f4f0de2">&#9670;&#160;</a></span>paretovariate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_integral_v&lt;OutputT&gt; || std::is_same_v&lt;OutputT, <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a>&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">const double <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::paretovariate </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pareto distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>double, the shape parameter. Cannot be 0.0.</td></tr>
  </table>
  </dd>
</dl>
<p>Important notice: the implemented code is a translation from Python <a href="https://github.com/python/cpython/blob/3.11/Lib/random.py">https://github.com/python/cpython/blob/3.11/Lib/random.py</a> into c++.</p>
<p>Pareto distribution. </p>

<p class="reference">References <a class="el" href="#ga3c08475e886d4f45f706ac4509a907d8">uniform()</a>.</p>

</div>
</div>
<a id="gae089b6fbf9fb202e2c629f81571d196f" name="gae089b6fbf9fb202e2c629f81571d196f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae089b6fbf9fb202e2c629f81571d196f">&#9670;&#160;</a></span>randbytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_integral_v&lt;OutputT&gt; || std::is_same_v&lt;OutputT, <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a>&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::uint8_t &gt; <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::randbytes </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates n random bytes. </p>
<p>This method should not be used for generating security tokens.</p>
<p>Generates n random bytes. </p>

<p class="reference">References <a class="el" href="#ga3c08475e886d4f45f706ac4509a907d8">uniform()</a>.</p>

</div>
</div>
<a id="ga8439b06864112e2ca8604d965d7e475f" name="ga8439b06864112e2ca8604d965d7e475f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8439b06864112e2ca8604d965d7e475f">&#9670;&#160;</a></span>randint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_integral_v&lt;T&gt;</div>
<div class="memtemplate">
template&lt;typename T&gt; <br />
requires std::is_integral_v&lt;T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::randint </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a random integer in range [a, b], including both end points. </p>
<p>Template argument T must be an integral type.</p>
<p>Returns random integer in range [a, b], including both end points. </p>

<p class="reference">References <a class="el" href="#ga3c08475e886d4f45f706ac4509a907d8">uniform()</a>.</p>

</div>
</div>
<a id="ga11b942e7b178cf7fe5ab5680b8ca9687" name="ga11b942e7b178cf7fe5ab5680b8ca9687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11b942e7b178cf7fe5ab5680b8ca9687">&#9670;&#160;</a></span>randrange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_arithmetic_v&lt;T&gt; &amp;&amp; std::is_arithmetic_v&lt;S&gt;</div>
<div class="memtemplate">
template&lt;typename T, typename S&gt; <br />
requires std::is_arithmetic_v&lt;T&gt; &amp;&amp; std::is_arithmetic_v&lt;S&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">const T <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::randrange </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>stop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S</td>          <td class="paramname"><span class="paramname"><em>step</em></span><span class="paramdefsep"> = </span><span class="paramdefval">S(1)</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a random value in range [start, stop) with specified step. </p>
<p>Template arguments T and S must be arithmetic types.</p>
<p>Chooses a random item from range [start, stop) with specified step. </p>

<p class="reference">References <a class="el" href="#ga3c08475e886d4f45f706ac4509a907d8">uniform()</a>.</p>

</div>
</div>
<a id="gaaaf19e546c65ac5ebc52d46034914277" name="gaaaf19e546c65ac5ebc52d46034914277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaaf19e546c65ac5ebc52d46034914277">&#9670;&#160;</a></span>sample() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_integral_v&lt;OutputT&gt; || std::is_same_v&lt;OutputT, <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a>&gt;</div>
<div class="memtemplate">
template&lt;typename T&gt; <br />
requires std::is_integral_v&lt;OutputT&gt; || std::is_same_v&lt;OutputT, <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a>&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::sample </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>population</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>k</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chooses k unique random elements from a population sequence. All population elements have same weight for the sampling and are each chosen only once. </p>
<p>Evaluates a vector containing elements from the population while leaving the original population unchanged. The resulting list is in selection order so that all sub-slices will also be valid random samples. This allows raffle winners (the sample) to be partitioned into grand prize and second place winners (the subslices).</p>
<p>Members of the population need not be unique. If the population contains repeats, then each occurrence is a possible selection in the sample.</p>
<p>Chooses k unique random elements from a population sequence (out std::vector, in container, default counts = 1). </p>

<p class="reference">References <a class="el" href="#ga3c08475e886d4f45f706ac4509a907d8">uniform()</a>.</p>

</div>
</div>
<a id="gae7627aeb3d6c10d723dbb2845056fe1c" name="gae7627aeb3d6c10d723dbb2845056fe1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7627aeb3d6c10d723dbb2845056fe1c">&#9670;&#160;</a></span>sample() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_integral_v&lt;C&gt;</div>
<div class="memtemplate">
template&lt;typename T, typename C&gt; <br />
requires std::is_integral_v&lt;C&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::sample </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>population</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; C &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>counts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>k</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Chooses k unique random elements from a population sequence (std::vector&lt;&gt;, with counts vector). </p>
<p>Evaluates a vector containing elements from the population while leaving the original population unchanged. The resulting list is in selection order so that all sub-slices will also be valid random samples. This allows raffle winners (the sample) to be partitioned into grand prize and second place winners (the subslices).</p>
<p>Members of the population need not be unique. If the population contains repeats, then each occurrence is a possible selection in the selection in the sample.</p>
<p>Repeated elements are specified by the counts parameter. For example: sample({"red", "blue"}, {4, 2}, 5); is equivalent to: sample({"red", "red", "red", "red", "blue", "blue"}, 5);</p>
<p>Chooses k unique random elements from a population sequence (std::vector&lt;&gt;, with counts vector). </p>

<p class="reference">References <a class="el" href="#ga3c08475e886d4f45f706ac4509a907d8">uniform()</a>.</p>

</div>
</div>
<a id="gaf50658949f3ac03f10639ef4eec8cae7" name="gaf50658949f3ac03f10639ef4eec8cae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf50658949f3ac03f10639ef4eec8cae7">&#9670;&#160;</a></span>seed() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_integral_v&lt;OutputT&gt; || std::is_same_v&lt;OutputT, <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a>&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::seed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes internal state (empty signature). </p>
<p>The seed value is evaluated from current time.</p>
<p>Initializes internal state (empty signature). </p>

<p>Reimplemented in <a class="el" href="group___c_w_g-algorithms.html#gaf0ab62de56bb08bf8e83e8a886633b00">BaseCWG&lt; ValueType, StateValueType, OutputType, OUTPUT_BITS &gt;</a>, <a class="el" href="group___c_w_g-algorithms.html#gaf0ab62de56bb08bf8e83e8a886633b00">BaseCWG&lt; std::uint64_t, std::uint64_t, std::uint64_t, 64 &gt;</a>, <a class="el" href="group___c_w_g-algorithms.html#gaf0ab62de56bb08bf8e83e8a886633b00">BaseCWG&lt; std::uint64_t, utils::UInt128, std::uint64_t, 64 &gt;</a>, <a class="el" href="group___c_w_g-algorithms.html#gaf0ab62de56bb08bf8e83e8a886633b00">BaseCWG&lt; utils::UInt128, utils::UInt128, utils::UInt128, 128 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga147f3f33109e62963fa242b8ea46dc70">BaseLFib64&lt; SIZE, K &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga147f3f33109e62963fa242b8ea46dc70">BaseLFib64&lt; 1279, 861 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga147f3f33109e62963fa242b8ea46dc70">BaseLFib64&lt; 17, 5 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga147f3f33109e62963fa242b8ea46dc70">BaseLFib64&lt; 55, 24 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga147f3f33109e62963fa242b8ea46dc70">BaseLFib64&lt; 607, 273 &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#gac94b3adb2deff2684c95dd29b9690bcf">BaseMELG&lt; SIZE &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#gac94b3adb2deff2684c95dd29b9690bcf">BaseMELG&lt; 10 &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#gac94b3adb2deff2684c95dd29b9690bcf">BaseMELG&lt; 312 &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#gac94b3adb2deff2684c95dd29b9690bcf">BaseMELG&lt; 696 &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#gabe45b8beede690e9dfde1c5c701d9125">BaseMRG31&lt; SIZE &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#gabe45b8beede690e9dfde1c5c701d9125">BaseMRG31&lt; 1597 &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#gabe45b8beede690e9dfde1c5c701d9125">BaseMRG31&lt; 47 &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#gaf45ea752c810b2667ad245a9570c0c7a">BaseMRG32&lt; SIZE &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#gaf45ea752c810b2667ad245a9570c0c7a">BaseMRG32&lt; 256 &gt;</a>, <a class="el" href="group___squares-algorithms.html#ga019ca329537ce2f6d08153095b78988a">BaseSquares&lt; OutputT &gt;</a>, <a class="el" href="group___squares-algorithms.html#ga019ca329537ce2f6d08153095b78988a">BaseSquares&lt; std::uint32_t &gt;</a>, <a class="el" href="group___squares-algorithms.html#ga019ca329537ce2f6d08153095b78988a">BaseSquares&lt; std::uint64_t &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#ga29097d11f36880d9e312ea7591d0ef3e">BaseWell&lt; SIZE &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#ga29097d11f36880d9e312ea7591d0ef3e">BaseWell&lt; 1391 &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#ga29097d11f36880d9e312ea7591d0ef3e">BaseWell&lt; 16 &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#ga29097d11f36880d9e312ea7591d0ef3e">BaseWell&lt; 32 &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#ga29097d11f36880d9e312ea7591d0ef3e">BaseWell&lt; 624 &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#gafac318ad57a8a083f06fc7fc9f7570f5">BaseXoroshiro&lt; SIZE &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#gafac318ad57a8a083f06fc7fc9f7570f5">BaseXoroshiro&lt; 16 &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#gafac318ad57a8a083f06fc7fc9f7570f5">BaseXoroshiro&lt; 4 &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#gafac318ad57a8a083f06fc7fc9f7570f5">BaseXoroshiro&lt; 8 &gt;</a>, <a class="el" href="class_cwg128.html#ab805f5413b8b3d17a351068994001a17">Cwg128</a>, <a class="el" href="class_cwg128__64.html#a1231a135515a5366858f41b9488ca1bb">Cwg128_64</a>, <a class="el" href="class_cwg64.html#ab370ece836868e364c0112556f29cac1">Cwg64</a>, <a class="el" href="group___l_c_g-algorithms.html#gacaa22b9094f30df565a0ea42b31a295a">FastRand32</a>, <a class="el" href="group___l_c_g-algorithms.html#gaf6b5b93789fead7de166e91e30755d1c">FastRand63</a>, <a class="el" href="class_melg19937.html#a5ac3f5aa21254fbc90d28a445e2cc1b4">Melg19937</a>, <a class="el" href="class_melg44497.html#a60e1d513a9b82ef774a6221ccc9d958d">Melg44497</a>, <a class="el" href="class_melg607.html#a4bfa36bc4f5fc0071667b9ca1cdfad8f">Melg607</a>, <a class="el" href="class_pcg1024__32.html#ac87ed386e7fc788e8a0f4fa750d72657">Pcg1024_32</a>, <a class="el" href="class_pcg128__64.html#a1986b5bb0a61e0be0c20d2a328027b31">Pcg128_64</a>, and <a class="el" href="class_pcg64__32.html#a0bb83e7597bd7f578919d71e6d5ce806">Pcg64_32</a>.</p>

<p class="reference">References <a class="el" href="#gaf50658949f3ac03f10639ef4eec8cae7">seed()</a>, and <a class="el" href="group__seed__generation.html#ga7a66acce4e57252c5dea6da90833b6ac">utils::set_random_seed64()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#gaf50658949f3ac03f10639ef4eec8cae7">seed()</a>, <a class="el" href="#gac8106d037d8f18e17901d5b8c4632863">seed()</a>, <a class="el" href="#ga88b7e4afc3516140ee5d6721c6ec1212">seed()</a>, <a class="el" href="#ga387834ddb1430f92cf5c5976fba95257">seed()</a>, <a class="el" href="#gaf7d908c937f886baaa7624313a62cfb9">seed()</a>, and <a class="el" href="#ga2d2460b994956f0e4ecac473d2055024">seed()</a>.</p>

</div>
</div>
<a id="gac8106d037d8f18e17901d5b8c4632863" name="gac8106d037d8f18e17901d5b8c4632863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8106d037d8f18e17901d5b8c4632863">&#9670;&#160;</a></span>seed() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_integral_v&lt;OutputT&gt; || std::is_same_v&lt;OutputT, <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a>&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::seed </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>seed_</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initalizes internal state from a double seed. </p>
<p>ief Initalizes internal state from a double seed. </p>

<p class="reference">References <a class="el" href="#gaf50658949f3ac03f10639ef4eec8cae7">seed()</a>.</p>

</div>
</div>
<a id="ga88b7e4afc3516140ee5d6721c6ec1212" name="ga88b7e4afc3516140ee5d6721c6ec1212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88b7e4afc3516140ee5d6721c6ec1212">&#9670;&#160;</a></span>seed() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_integral_v&lt;OutputT&gt; || std::is_same_v&lt;OutputT, <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a>&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::seed </td>
          <td>(</td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>seed_</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes internal state from a 32-bits signed integer seed. </p>
<p>Initializes internal state from a 32-bits signed integer seed. </p>

<p class="reference">References <a class="el" href="#gaf50658949f3ac03f10639ef4eec8cae7">seed()</a>.</p>

</div>
</div>
<a id="ga387834ddb1430f92cf5c5976fba95257" name="ga387834ddb1430f92cf5c5976fba95257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga387834ddb1430f92cf5c5976fba95257">&#9670;&#160;</a></span>seed() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_integral_v&lt;OutputT&gt; || std::is_same_v&lt;OutputT, <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a>&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::seed </td>
          <td>(</td>
          <td class="paramtype">const long long</td>          <td class="paramname"><span class="paramname"><em>seed_</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes internal state from a 64-bits unsigned integer seed. </p>
<p>Initializes internal state from a 64-bits signed integer seed. </p>

<p class="reference">References <a class="el" href="#gaf50658949f3ac03f10639ef4eec8cae7">seed()</a>.</p>

</div>
</div>
<a id="gaf7d908c937f886baaa7624313a62cfb9" name="gaf7d908c937f886baaa7624313a62cfb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7d908c937f886baaa7624313a62cfb9">&#9670;&#160;</a></span>seed() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_integral_v&lt;OutputT&gt; || std::is_same_v&lt;OutputT, <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a>&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::seed </td>
          <td>(</td>
          <td class="paramtype">const long</td>          <td class="paramname"><span class="paramname"><em>seed_</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes internal state from a 32-bits unsigned integer seed. </p>
<p>Initializes internal state from a 32-bits signed integer seed. </p>

<p class="reference">References <a class="el" href="#gaf50658949f3ac03f10639ef4eec8cae7">seed()</a>.</p>

</div>
</div>
<a id="ga2d2460b994956f0e4ecac473d2055024" name="ga2d2460b994956f0e4ecac473d2055024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d2460b994956f0e4ecac473d2055024">&#9670;&#160;</a></span>seed() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_integral_v&lt;OutputT&gt; || std::is_same_v&lt;OutputT, <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a>&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::seed </td>
          <td>(</td>
          <td class="paramtype">const unsigned int</td>          <td class="paramname"><span class="paramname"><em>seed_</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes internal state from a 32-bits unsigned integer seed. </p>
<p>Initializes internal state from a 32-bits unsigned integer seed. </p>

<p class="reference">References <a class="el" href="#gaf50658949f3ac03f10639ef4eec8cae7">seed()</a>.</p>

</div>
</div>
<a id="gadc6434f1f216d9ba2d936c8d671e7d3e" name="gadc6434f1f216d9ba2d936c8d671e7d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc6434f1f216d9ba2d936c8d671e7d3e">&#9670;&#160;</a></span>seed() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_integral_v&lt;OutputT&gt; || std::is_same_v&lt;OutputT, <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a>&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::seed </td>
          <td>(</td>
          <td class="paramtype">const unsigned long long</td>          <td class="paramname"><span class="paramname"><em>seed_</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes internal state from a 64-bits unsigned integer seed. </p>
<p>Initializes internal state from a 64-bits unsigned integer seed. </p>

<p class="reference">References <a class="el" href="class_base_random.html#a1bfcea4fbbdbfe98cfd307cfbfba6de7">_setstate()</a>.</p>

</div>
</div>
<a id="gae3ec11e03404f276381459e668dedddd" name="gae3ec11e03404f276381459e668dedddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3ec11e03404f276381459e668dedddd">&#9670;&#160;</a></span>seed() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_integral_v&lt;OutputT&gt; || std::is_same_v&lt;OutputT, <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a>&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::seed </td>
          <td>(</td>
          <td class="paramtype">const unsigned long</td>          <td class="paramname"><span class="paramname"><em>seed_</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes internal state from a 32-bits unsigned integer seed. </p>
<p>Initializes internal state from a 32-bits unsigned integer seed. </p>

<p class="reference">References <a class="el" href="class_base_random.html#a1bfcea4fbbdbfe98cfd307cfbfba6de7">_setstate()</a>.</p>

</div>
</div>
<a id="ga00b4ca2ee21072e6cdd4f3f850608375" name="ga00b4ca2ee21072e6cdd4f3f850608375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00b4ca2ee21072e6cdd4f3f850608375">&#9670;&#160;</a></span>seed() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_integral_v&lt;OutputT&gt; || std::is_same_v&lt;OutputT, <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a>&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::seed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>seed_</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the internal state of this PRNG with a 128-bits integer seed. </p>
<p>Initializes the internal state of this PRNG with a 128-bits integer seed. </p>

<p>Reimplemented in <a class="el" href="group___c_w_g-algorithms.html#ga50f9db41b61b0df0a7f0e871b164b8d6">BaseCWG&lt; ValueType, StateValueType, OutputType, OUTPUT_BITS &gt;</a>, <a class="el" href="group___c_w_g-algorithms.html#ga50f9db41b61b0df0a7f0e871b164b8d6">BaseCWG&lt; std::uint64_t, std::uint64_t, std::uint64_t, 64 &gt;</a>, <a class="el" href="group___c_w_g-algorithms.html#ga50f9db41b61b0df0a7f0e871b164b8d6">BaseCWG&lt; std::uint64_t, utils::UInt128, std::uint64_t, 64 &gt;</a>, <a class="el" href="group___c_w_g-algorithms.html#ga50f9db41b61b0df0a7f0e871b164b8d6">BaseCWG&lt; utils::UInt128, utils::UInt128, utils::UInt128, 128 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga151036620ea32e3fe0102cfe7213ce41">BaseLFib64&lt; SIZE, K &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga151036620ea32e3fe0102cfe7213ce41">BaseLFib64&lt; 1279, 861 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga151036620ea32e3fe0102cfe7213ce41">BaseLFib64&lt; 17, 5 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga151036620ea32e3fe0102cfe7213ce41">BaseLFib64&lt; 55, 24 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga151036620ea32e3fe0102cfe7213ce41">BaseLFib64&lt; 607, 273 &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#ga858139460bd8c4af86f7434c4733d0dd">BaseMELG&lt; SIZE &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#ga858139460bd8c4af86f7434c4733d0dd">BaseMELG&lt; 10 &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#ga858139460bd8c4af86f7434c4733d0dd">BaseMELG&lt; 312 &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#ga858139460bd8c4af86f7434c4733d0dd">BaseMELG&lt; 696 &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#gad09ff6dc141be48b35a824744514a7de">BaseMRG31&lt; SIZE &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#gad09ff6dc141be48b35a824744514a7de">BaseMRG31&lt; 1597 &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#gad09ff6dc141be48b35a824744514a7de">BaseMRG31&lt; 47 &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#ga55ed0c90ee4c31cee02fc6a23a8db3b5">BaseMRG32&lt; SIZE &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#ga55ed0c90ee4c31cee02fc6a23a8db3b5">BaseMRG32&lt; 256 &gt;</a>, <a class="el" href="group___squares-algorithms.html#ga322f382cd044b32323f53877a5220fd5">BaseSquares&lt; OutputT &gt;</a>, <a class="el" href="group___squares-algorithms.html#ga322f382cd044b32323f53877a5220fd5">BaseSquares&lt; std::uint32_t &gt;</a>, <a class="el" href="group___squares-algorithms.html#ga322f382cd044b32323f53877a5220fd5">BaseSquares&lt; std::uint64_t &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#gad8206c15cb53771dc7da55dfd3e0ea53">BaseWell&lt; SIZE &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#gad8206c15cb53771dc7da55dfd3e0ea53">BaseWell&lt; 1391 &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#gad8206c15cb53771dc7da55dfd3e0ea53">BaseWell&lt; 16 &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#gad8206c15cb53771dc7da55dfd3e0ea53">BaseWell&lt; 32 &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#gad8206c15cb53771dc7da55dfd3e0ea53">BaseWell&lt; 624 &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#gae616aab5761d6ada7f3dd5d23ec7eff6">BaseXoroshiro&lt; SIZE &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#gae616aab5761d6ada7f3dd5d23ec7eff6">BaseXoroshiro&lt; 16 &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#gae616aab5761d6ada7f3dd5d23ec7eff6">BaseXoroshiro&lt; 4 &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#gae616aab5761d6ada7f3dd5d23ec7eff6">BaseXoroshiro&lt; 8 &gt;</a>, <a class="el" href="class_cwg128.html#a317b547415b7915c5a2a265b67c1a30c">Cwg128</a>, <a class="el" href="class_cwg128__64.html#ae83883db1abd1ff5af121b559b336873">Cwg128_64</a>, <a class="el" href="class_cwg64.html#a8de8e2fb75b11a23bc18b14d704200bb">Cwg64</a>, <a class="el" href="group___l_c_g-algorithms.html#ga6c6fe798e7804b75506c10bf6d07cc6c">FastRand32</a>, <a class="el" href="group___l_c_g-algorithms.html#ga710f1d2b981998a1eaf39514f3449315">FastRand63</a>, <a class="el" href="class_melg19937.html#a66cb29f8f58296ab70ed51c57d899c8e">Melg19937</a>, <a class="el" href="class_melg44497.html#ac00ca0e0fe31a6c262c1bb0336ef913e">Melg44497</a>, <a class="el" href="class_melg607.html#a6b2f86bd91e08a1d35a464eabcfe9a0b">Melg607</a>, <a class="el" href="class_pcg1024__32.html#a473e92dfe4ad66a679ab84db106b2466">Pcg1024_32</a>, <a class="el" href="class_pcg128__64.html#ab92294d206027e18784e5717c4e6265e">Pcg128_64</a>, and <a class="el" href="class_pcg64__32.html#a73d79e307303477282554c18124d9a3e">Pcg64_32</a>.</p>

<p class="reference">References <a class="el" href="class_base_random.html#a1bfcea4fbbdbfe98cfd307cfbfba6de7">_setstate()</a>.</p>

</div>
</div>
<a id="gafb899e92eb6b4ae2217ba2d4b96b7fec" name="gafb899e92eb6b4ae2217ba2d4b96b7fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb899e92eb6b4ae2217ba2d4b96b7fec">&#9670;&#160;</a></span>setstate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_integral_v&lt;OutputT&gt; || std::is_same_v&lt;OutputT, <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a>&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::setstate </td>
          <td>(</td>
          <td class="paramtype">const StateT &amp;</td>          <td class="paramname"><span class="paramname"><em>new_internal_state</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the internal state from a new internal state content. </p>
<p>Sets the internal state from a new internal state content. </p>

</div>
</div>
<a id="ga56920e73800fd5a1e689e490a5cb21c2" name="ga56920e73800fd5a1e689e490a5cb21c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56920e73800fd5a1e689e490a5cb21c2">&#9670;&#160;</a></span>setstate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_integral_v&lt;OutputT&gt; || std::is_same_v&lt;OutputT, <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a>&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::setstate </td>
          <td>(</td>
          <td class="paramtype">const StateT &amp;</td>          <td class="paramname"><span class="paramname"><em>new_internal_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>gauss_next</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restores internal state from a new internal state content and with gauss_next. </p>
<p>Sets the internal state from a new internal state content and gauss_next. </p>

</div>
</div>
<a id="gabe28727e6672d692f12e8ce98b0d130a" name="gabe28727e6672d692f12e8ce98b0d130a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe28727e6672d692f12e8ce98b0d130a">&#9670;&#160;</a></span>setstate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_integral_v&lt;OutputT&gt; || std::is_same_v&lt;OutputT, <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a>&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::setstate </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_base_random_1_1___internal_state.html">_InternalState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>new_internal_state</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restores internal state from object returned by <a class="el" href="class_base_random.html#ad3504565dc9bd81a27af0e00a27eeb83" title="Returns the internal state of this PRNG; can be later passed to setstate().">getstate()</a>. </p>
<p>Restores internal state from object returned by <a class="el" href="class_base_random.html#ad3504565dc9bd81a27af0e00a27eeb83" title="Returns the internal state of this PRNG; can be later passed to setstate().">getstate()</a>. </p>

<p class="reference">Referenced by <a class="el" href="class_squares32.html#a7045ae44fe20c6445e652fa94cf2b4a5">Squares32::Squares32()</a>, and <a class="el" href="class_squares64.html#ac475efae4da2122957e47187531f564d">Squares64::Squares64()</a>.</p>

</div>
</div>
<a id="ga3163040e9149d9c50a867e44511c88fe" name="ga3163040e9149d9c50a867e44511c88fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3163040e9149d9c50a867e44511c88fe">&#9670;&#160;</a></span>shuffle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires utils::is_indexable_v&lt;ContainerType&gt;</div>
<div class="memtemplate">
template&lt;typename ContainerType&gt; <br />
requires utils::is_indexable_v&lt;ContainerType&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::shuffle </td>
          <td>(</td>
          <td class="paramtype">ContainerType &amp;</td>          <td class="paramname"><span class="paramname"><em>seq</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In place Shuffles the specified sequence. </p>
<p>The Container type must be either std::vector or std::array.</p>
<p>Shuffles specified sequence in place. </p>

<p class="reference">References <a class="el" href="#ga3c08475e886d4f45f706ac4509a907d8">uniform()</a>.</p>

</div>
</div>
<a id="gaeb4a7ee56265e93551bb7e931543e7df" name="gaeb4a7ee56265e93551bb7e931543e7df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb4a7ee56265e93551bb7e931543e7df">&#9670;&#160;</a></span>state()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_integral_v&lt;OutputT&gt; || std::is_same_v&lt;OutputT, <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a>&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const StateT <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::state </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current internal state value. </p>
<p>Returns the current internal state value. </p>

</div>
</div>
<a id="ga3b791d56d12aafeb87e425c0e8fe7010" name="ga3b791d56d12aafeb87e425c0e8fe7010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b791d56d12aafeb87e425c0e8fe7010">&#9670;&#160;</a></span>triangular() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_integral_v&lt;OutputT&gt; || std::is_same_v&lt;OutputT, <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a>&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::triangular </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Triangular distribution (low=0.0, high=1.0, mode=0.5). </p>
<p>Triangular distribution (low=0.0, high=1.0, mode=0.5). </p>

<p class="reference">References <a class="el" href="#ga3b791d56d12aafeb87e425c0e8fe7010">triangular()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#ga3b791d56d12aafeb87e425c0e8fe7010">triangular()</a>, and <a class="el" href="#ga55a55b28439200715c1a42d304883422">triangular()</a>.</p>

</div>
</div>
<a id="ga55a55b28439200715c1a42d304883422" name="ga55a55b28439200715c1a42d304883422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55a55b28439200715c1a42d304883422">&#9670;&#160;</a></span>triangular() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_integral_v&lt;OutputT&gt; || std::is_same_v&lt;OutputT, <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a>&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::triangular </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>low</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>high</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Triangular distribution (low, high, default mode). </p>
<p>Triangular distribution (low, high, default mode). </p>

<p class="reference">References <a class="el" href="#ga3b791d56d12aafeb87e425c0e8fe7010">triangular()</a>.</p>

</div>
</div>
<a id="gaccf4702117a9d9490a87e00c16d05cef" name="gaccf4702117a9d9490a87e00c16d05cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccf4702117a9d9490a87e00c16d05cef">&#9670;&#160;</a></span>triangular() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_integral_v&lt;OutputT&gt; || std::is_same_v&lt;OutputT, <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a>&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::triangular </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>low</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>high</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>mode</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Triangular distribution (low, high, mode). </p>
<p>Important notice: the implemented code is a translation from Python <a href="https://github.com/python/cpython/blob/3.11/Lib/random.py">https://github.com/python/cpython/blob/3.11/Lib/random.py</a> into c++.</p>
<p>Triangular distribution (low, high, mode). </p>

<p class="reference">References <a class="el" href="#ga3c08475e886d4f45f706ac4509a907d8">uniform()</a>.</p>

</div>
</div>
<a id="ga3c08475e886d4f45f706ac4509a907d8" name="ga3c08475e886d4f45f706ac4509a907d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c08475e886d4f45f706ac4509a907d8">&#9670;&#160;</a></span>uniform() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_floating_point_v&lt;T&gt;</div>
<div class="memtemplate">
template&lt;typename T&gt; <br />
requires std::is_floating_point_v&lt;T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::uniform </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uniform distribution in [0.0, 1.0). </p>
<p>Uniform distribution in [0.0, 1.0). </p>

<p class="reference">References <a class="el" href="class_base_random.html#a57537c60d9dbfbebdadbc3aacd96eb86">random()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#gae9e46564b6f810a9cf529c8b5349727a">binomialvariate()</a>, <a class="el" href="#gae81fe65366b54ec3a9b2975860ce75b3">choice()</a>, <a class="el" href="#ga1889ab84371fc977b0e9816665e17231">choices_cum()</a>, <a class="el" href="#gad6d05022f14a2c7c07a069f8bfec1726">expovariate()</a>, <a class="el" href="#ga936e58e8231d9194bf32d9338999bff4">gammavariate()</a>, <a class="el" href="#ga3f118338c6e34fb76adb2343edfd3ace">gauss()</a>, <a class="el" href="#gad2e569db15494aecaadd2f4a10994cb8">n_evaluate()</a>, <a class="el" href="#ga3a3b756d83d04d3e97e50821ab2b6a0a">n_evaluate()</a>, <a class="el" href="#gab6e7d519beb865b4f0919e8926fcd35e">n_evaluate()</a>, <a class="el" href="#gafe36a7b2090bdb7d075b8eb83397a64b">normalvariate()</a>, <a class="el" href="#ga4349e1bc8f006808a75fc4a92600f601">operator()()</a>, <a class="el" href="#ga5ad7362cdb71f98daf788568308efc85">operator()()</a>, <a class="el" href="#ga2db32c9eaadf2a8fb42e325054e825d1">operator()()</a>, <a class="el" href="#gac0a4f78d80b39e6182298266c9e50ce7">operator()()</a>, <a class="el" href="#ga0cff174221c75a002099d2ce9246ae84">operator()()</a>, <a class="el" href="#gadbc667bf6cdca6c744390aa48f4f0de2">paretovariate()</a>, <a class="el" href="#gae089b6fbf9fb202e2c629f81571d196f">randbytes()</a>, <a class="el" href="#ga8439b06864112e2ca8604d965d7e475f">randint()</a>, <a class="el" href="#ga11b942e7b178cf7fe5ab5680b8ca9687">randrange()</a>, <a class="el" href="#gaaaf19e546c65ac5ebc52d46034914277">sample()</a>, <a class="el" href="#gae7627aeb3d6c10d723dbb2845056fe1c">sample()</a>, <a class="el" href="#ga3163040e9149d9c50a867e44511c88fe">shuffle()</a>, <a class="el" href="#gaccf4702117a9d9490a87e00c16d05cef">triangular()</a>, <a class="el" href="#ga15a53c095b66916ce70a91b0c1772498">vonmisesvariate()</a>, and <a class="el" href="#gab860b1b1b792c32efe3ad1f16eab254c">weibullvariate()</a>.</p>

</div>
</div>
<a id="ga2f1713879cb60593098161cc84a3f164" name="ga2f1713879cb60593098161cc84a3f164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f1713879cb60593098161cc84a3f164">&#9670;&#160;</a></span>uniform() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_arithmetic_v&lt;T&gt; &amp;&amp; std::is_arithmetic_v&lt;U&gt;</div>
<div class="memtemplate">
template&lt;typename T, typename U&gt; <br />
requires std::is_arithmetic_v&lt;T&gt; &amp;&amp; std::is_arithmetic_v&lt;U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::uniform </td>
          <td>(</td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>max</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uniform distribution [0.0, max). </p>
<p>Uniform distribution in [0.0, max). </p>

<p class="reference">References <a class="el" href="class_base_random.html#a57537c60d9dbfbebdadbc3aacd96eb86">random()</a>.</p>

</div>
</div>
<a id="gaa4fc4c76e0b02e6aed29297b579687c9" name="gaa4fc4c76e0b02e6aed29297b579687c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4fc4c76e0b02e6aed29297b579687c9">&#9670;&#160;</a></span>uniform() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_arithmetic_v&lt;T&gt; &amp;&amp; std::is_arithmetic_v&lt;U&gt; &amp;&amp; std::is_arithmetic_v&lt;V&gt;</div>
<div class="memtemplate">
template&lt;typename T, typename U, typename V&gt; <br />
requires std::is_arithmetic_v&lt;T&gt; &amp;&amp; std::is_arithmetic_v&lt;U&gt; &amp;&amp; std::is_arithmetic_v&lt;V&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::uniform </td>
          <td>(</td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V</td>          <td class="paramname"><span class="paramname"><em>max</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uniform distribution in [min, max). </p>
<p>Uniform distribution in [min, max). </p>

<p class="reference">References <a class="el" href="class_base_random.html#a57537c60d9dbfbebdadbc3aacd96eb86">random()</a>.</p>

</div>
</div>
<a id="ga15a53c095b66916ce70a91b0c1772498" name="ga15a53c095b66916ce70a91b0c1772498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15a53c095b66916ce70a91b0c1772498">&#9670;&#160;</a></span>vonmisesvariate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_integral_v&lt;OutputT&gt; || std::is_same_v&lt;OutputT, <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a>&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">const double <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::vonmisesvariate </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>mu</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>kappa</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Circular data distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mu</td><td>is the mean angle, expressed in radians between 0 and 2*pi </td></tr>
    <tr><td class="paramname">kappa</td><td>is the concentration parameter, which must be greater than or equal to zero. If kappa is equal to zero, this distribution reduces to a uniform random angle over the range 0 to 2*pi.</td></tr>
  </table>
  </dd>
</dl>
<p>Important notice: the implemented code is a translation from Python <a href="https://github.com/python/cpython/blob/3.11/Lib/random.py">https://github.com/python/cpython/blob/3.11/Lib/random.py</a> into c++. As such, some comments present in the Python original code have been copied as is in this c++ implementation, naming then the authors of the related parts of code.</p>
<p>Circular data distribution. </p>

<p class="reference">References <a class="el" href="#ga3c08475e886d4f45f706ac4509a907d8">uniform()</a>.</p>

</div>
</div>
<a id="gab860b1b1b792c32efe3ad1f16eab254c" name="gab860b1b1b792c32efe3ad1f16eab254c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab860b1b1b792c32efe3ad1f16eab254c">&#9670;&#160;</a></span>weibullvariate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; <br />
requires std::is_integral_v&lt;OutputT&gt; || std::is_same_v&lt;OutputT, <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a>&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">const double <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::weibullvariate </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Weibull distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>double, the scale parameter. </td></tr>
    <tr><td class="paramname">beta</td><td>double, the shape parameter. Must be non null.</td></tr>
  </table>
  </dd>
</dl>
<p>Weibull distribution. </p>

<p class="reference">References <a class="el" href="#ga3c08475e886d4f45f706ac4509a907d8">uniform()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on <span class="timestamp"></span> for CppRandLib - c++20 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
