<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CppRandLib - c++11: algos: BaseRandom - Base class for all PRNGs (Pseudo Random Numbers Generators)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CppRandLib - c++11<span id="projectnumber">&#160;2.1.2</span>
   </div>
   <div id="projectbrief">Best-in-class Pseudo Random Number Generators</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('group___base_random.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">algos: BaseRandom - Base class for all PRNGs (Pseudo Random Numbers Generators) </div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:BaseRandom_3C_20StateT_2C_20OutputT_2C_20OUTPUT_5FBITS_20_3E" id="r_BaseRandom_3C_20StateT_2C_20OutputT_2C_20OUTPUT_5FBITS_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_base_random.html">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base class for all pseudo-random numbers generators.  <a href="class_base_random.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaed12b45277ba1dc14ceee61f26f2ef40" id="r_gaed12b45277ba1dc14ceee61f26f2ef40"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaed12b45277ba1dc14ceee61f26f2ef40">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::betavariate</a> (const double alpha, const double beta)</td></tr>
<tr class="memdesc:gaed12b45277ba1dc14ceee61f26f2ef40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Beta distribution.  <br /></td></tr>
<tr class="memitem:gafc4b4494902512708c6611366b41044d" id="r_gafc4b4494902512708c6611366b41044d"><td class="memTemplParams" colspan="2">template&lt;typename CountT, typename ProbaT&gt; </td></tr>
<tr class="memitem:gafc4b4494902512708c6611366b41044d template"><td class="memItemLeft" align="right" valign="top">const CountT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafc4b4494902512708c6611366b41044d">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::binomialvariate</a> (CountT n=1, const ProbaT p=ProbaT(0.5))</td></tr>
<tr class="memdesc:gafc4b4494902512708c6611366b41044d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of successes for n&gt;=0 independent trials.  <br /></td></tr>
<tr class="memitem:gaea6eb3e08499a26f9ea65250fcf83c19" id="r_gaea6eb3e08499a26f9ea65250fcf83c19"><td class="memTemplParams" colspan="2">template&lt;typename T, const std::size_t n&gt; </td></tr>
<tr class="memitem:gaea6eb3e08499a26f9ea65250fcf83c19 template"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaea6eb3e08499a26f9ea65250fcf83c19">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::choice</a> (const std::array&lt; T, n &gt; &amp;seq)</td></tr>
<tr class="memdesc:gaea6eb3e08499a26f9ea65250fcf83c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chooses a random element from a non-empty sequence (std::array).  <br /></td></tr>
<tr class="memitem:gad4d317c0bb6478aab7598b18659eec07" id="r_gad4d317c0bb6478aab7598b18659eec07"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:gad4d317c0bb6478aab7598b18659eec07 template"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad4d317c0bb6478aab7598b18659eec07">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::choice</a> (const std::vector&lt; T &gt; &amp;seq)</td></tr>
<tr class="memdesc:gad4d317c0bb6478aab7598b18659eec07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chooses a random element from a non-empty sequence (std::vector).  <br /></td></tr>
<tr class="memitem:ga4142d2e866225a4ef30f79d90ffa88ba" id="r_ga4142d2e866225a4ef30f79d90ffa88ba"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ga4142d2e866225a4ef30f79d90ffa88ba template"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4142d2e866225a4ef30f79d90ffa88ba">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::choices</a> (const std::vector&lt; T &gt; &amp;population, const std::size_t k)</td></tr>
<tr class="memdesc:ga4142d2e866225a4ef30f79d90ffa88ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a k sized vector of elements chosen from the population with replacement (same weights).  <br /></td></tr>
<tr class="memitem:ga55fb36e312a372d16b339b639b149632" id="r_ga55fb36e312a372d16b339b639b149632"><td class="memTemplParams" colspan="2">template&lt;typename T, typename C&gt; </td></tr>
<tr class="memitem:ga55fb36e312a372d16b339b639b149632 template"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga55fb36e312a372d16b339b639b149632">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::choices</a> (const std::vector&lt; T &gt; &amp;population, std::vector&lt; C &gt; &amp;weights, const std::size_t k)</td></tr>
<tr class="memdesc:ga55fb36e312a372d16b339b639b149632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a k sized vector of elements chosen from the population with replacement (individual weights).  <br /></td></tr>
<tr class="memitem:gac51f62e6a02a9f2d0084f0ce22a07f18" id="r_gac51f62e6a02a9f2d0084f0ce22a07f18"><td class="memTemplParams" colspan="2">template&lt;typename T, typename C&gt; </td></tr>
<tr class="memitem:gac51f62e6a02a9f2d0084f0ce22a07f18 template"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac51f62e6a02a9f2d0084f0ce22a07f18">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::choices_cum</a> (const std::vector&lt; T &gt; &amp;population, const std::vector&lt; C &gt; &amp;cum_weights, const std::size_t k)</td></tr>
<tr class="memdesc:gac51f62e6a02a9f2d0084f0ce22a07f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a k sized vector of elements chosen from the population with replacement (cumulative weights).  <br /></td></tr>
<tr class="memitem:ga18d7abf6f8898fb186eced8d8db6c40c" id="r_ga18d7abf6f8898fb186eced8d8db6c40c"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga18d7abf6f8898fb186eced8d8db6c40c">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::expovariate</a> (const double lambda=1.0)</td></tr>
<tr class="memdesc:ga18d7abf6f8898fb186eced8d8db6c40c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exponential distribution.  <br /></td></tr>
<tr class="memitem:ga3d1130df7b8d9630100c810088206596" id="r_ga3d1130df7b8d9630100c810088206596"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3d1130df7b8d9630100c810088206596">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::gammavariate</a> (const double alpha, const double beta)</td></tr>
<tr class="memdesc:ga3d1130df7b8d9630100c810088206596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gamma distribution. This is NOT the gamma function!  <br /></td></tr>
<tr class="memitem:ga8a666db0bc34218dd06f633f94644f15" id="r_ga8a666db0bc34218dd06f633f94644f15"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8a666db0bc34218dd06f633f94644f15">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::gauss</a> () noexcept</td></tr>
<tr class="memdesc:ga8a666db0bc34218dd06f633f94644f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Gaussian distribution (mean=0.0, stdev=1.0).  <br /></td></tr>
<tr class="memitem:gae879ae952c45bad110e45a671fafed3d" id="r_gae879ae952c45bad110e45a671fafed3d"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae879ae952c45bad110e45a671fafed3d">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::gauss</a> (const double mu, const double sigma)</td></tr>
<tr class="memdesc:gae879ae952c45bad110e45a671fafed3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gaussian distribution (mean=mu, stdev=sigma).  <br /></td></tr>
<tr class="memitem:ga3eb4a34360f955c70c94c2bb551e456d" id="r_ga3eb4a34360f955c70c94c2bb551e456d"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3eb4a34360f955c70c94c2bb551e456d">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::lognormvariate</a> ()</td></tr>
<tr class="memdesc:ga3eb4a34360f955c70c94c2bb551e456d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Log normal distribution (mean=0.0, stdev=1.0).  <br /></td></tr>
<tr class="memitem:ga72f98396e7045aead22be7a676071ee4" id="r_ga72f98396e7045aead22be7a676071ee4"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga72f98396e7045aead22be7a676071ee4">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::lognormvariate</a> (const double mu, const double sigma)</td></tr>
<tr class="memdesc:ga72f98396e7045aead22be7a676071ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log normal distribution (mean=mu, stdev=sigma).  <br /></td></tr>
<tr class="memitem:gac17bfe15bfc24f45f332600c509af0bf" id="r_gac17bfe15bfc24f45f332600c509af0bf"><td class="memTemplParams" colspan="2">template&lt;typename T, const std::size_t n&gt; </td></tr>
<tr class="memitem:gac17bfe15bfc24f45f332600c509af0bf template"><td class="memItemLeft" align="right" valign="top">std::array&lt; T, n &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac17bfe15bfc24f45f332600c509af0bf">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::n_evaluate</a> ()</td></tr>
<tr class="memdesc:gac17bfe15bfc24f45f332600c509af0bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of n values that are uniformly contained within range [0.0, 1.0).  <br /></td></tr>
<tr class="memitem:gaa6e2821e442bde7866f82bbc5edc198b" id="r_gaa6e2821e442bde7866f82bbc5edc198b"><td class="memTemplParams" colspan="2">template&lt;typename T, const std::size_t m, typename U = T, const std::size_t n = m&gt; </td></tr>
<tr class="memitem:gaa6e2821e442bde7866f82bbc5edc198b template"><td class="memItemLeft" align="right" valign="top">std::array&lt; T, m &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa6e2821e442bde7866f82bbc5edc198b">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::n_evaluate</a> (const std::array&lt; U, n &gt; &amp;max)</td></tr>
<tr class="memdesc:gaa6e2821e442bde7866f82bbc5edc198b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of min(m, n) values in range [0; max[i]).  <br /></td></tr>
<tr class="memitem:ga6ca752783b82acd4e8f9234eb4d60457" id="r_ga6ca752783b82acd4e8f9234eb4d60457"><td class="memTemplParams" colspan="2">template&lt;typename T, const std::size_t m, typename U = T, const std::size_t n = m, typename V = U, const std::size_t p = n&gt; </td></tr>
<tr class="memitem:ga6ca752783b82acd4e8f9234eb4d60457 template"><td class="memItemLeft" align="right" valign="top">std::array&lt; T, m &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6ca752783b82acd4e8f9234eb4d60457">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::n_evaluate</a> (const std::array&lt; U, n &gt; &amp;min, const std::array&lt; V, p &gt; &amp;max)</td></tr>
<tr class="memdesc:ga6ca752783b82acd4e8f9234eb4d60457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array min(m, n, p) values in range [min[i]; max[i]).  <br /></td></tr>
<tr class="memitem:ga9102cc1375bafb0167d07137d666fd21" id="r_ga9102cc1375bafb0167d07137d666fd21"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ga9102cc1375bafb0167d07137d666fd21 template"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9102cc1375bafb0167d07137d666fd21">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::n_evaluate</a> (const std::size_t n)</td></tr>
<tr class="memdesc:ga9102cc1375bafb0167d07137d666fd21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of n values that are uniformly contained within range [0.0, 1.0).  <br /></td></tr>
<tr class="memitem:gada9e29de5440f3630cc1ed1200c2addc" id="r_gada9e29de5440f3630cc1ed1200c2addc"><td class="memTemplParams" colspan="2">template&lt;typename T, typename U = T&gt; </td></tr>
<tr class="memitem:gada9e29de5440f3630cc1ed1200c2addc template"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gada9e29de5440f3630cc1ed1200c2addc">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::n_evaluate</a> (const std::size_t n, const U max)</td></tr>
<tr class="memdesc:gada9e29de5440f3630cc1ed1200c2addc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of n values that are uniformly contained within range [0, max).  <br /></td></tr>
<tr class="memitem:ga0bbf20019058e6c797ed16a66cb0e276" id="r_ga0bbf20019058e6c797ed16a66cb0e276"><td class="memTemplParams" colspan="2">template&lt;typename T, typename U = T&gt; </td></tr>
<tr class="memitem:ga0bbf20019058e6c797ed16a66cb0e276 template"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0bbf20019058e6c797ed16a66cb0e276">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::n_evaluate</a> (const std::vector&lt; U &gt; &amp;max)</td></tr>
<tr class="memdesc:ga0bbf20019058e6c797ed16a66cb0e276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of n values in range [0; max[i]).  <br /></td></tr>
<tr class="memitem:ga806d5a87c263b5d46b6aca1653b9e713" id="r_ga806d5a87c263b5d46b6aca1653b9e713"><td class="memTemplParams" colspan="2">template&lt;typename T, typename U = T, typename V = U&gt; </td></tr>
<tr class="memitem:ga806d5a87c263b5d46b6aca1653b9e713 template"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga806d5a87c263b5d46b6aca1653b9e713">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::n_evaluate</a> (const std::vector&lt; U &gt; &amp;min, const std::vector&lt; V &gt; &amp;max)</td></tr>
<tr class="memdesc:ga806d5a87c263b5d46b6aca1653b9e713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of n values in range [min[i]; max[i]).  <br /></td></tr>
<tr class="memitem:ga17f2c7bc2d2887b512a06c70eeb901f2" id="r_ga17f2c7bc2d2887b512a06c70eeb901f2"><td class="memTemplParams" colspan="2">template&lt;typename T, const std::size_t n, typename U = T&gt; </td></tr>
<tr class="memitem:ga17f2c7bc2d2887b512a06c70eeb901f2 template"><td class="memItemLeft" align="right" valign="top">std::array&lt; T, n &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga17f2c7bc2d2887b512a06c70eeb901f2">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::n_evaluate</a> (const U max)</td></tr>
<tr class="memdesc:ga17f2c7bc2d2887b512a06c70eeb901f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of n values that are uniformly contained within range [0, max).  <br /></td></tr>
<tr class="memitem:ga68ef9857c13f946fa36bcde40a44b5f5" id="r_ga68ef9857c13f946fa36bcde40a44b5f5"><td class="memTemplParams" colspan="2">template&lt;typename T, const std::size_t n, typename U = T, typename V = U&gt; </td></tr>
<tr class="memitem:ga68ef9857c13f946fa36bcde40a44b5f5 template"><td class="memItemLeft" align="right" valign="top">std::array&lt; T, n &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga68ef9857c13f946fa36bcde40a44b5f5">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::n_evaluate</a> (const U min, const V max)</td></tr>
<tr class="memdesc:ga68ef9857c13f946fa36bcde40a44b5f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of n values that are uniformly contained within range [min, max).  <br /></td></tr>
<tr class="memitem:gaa9f450e514e0e2f811a3423e78b6bfba" id="r_gaa9f450e514e0e2f811a3423e78b6bfba"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa9f450e514e0e2f811a3423e78b6bfba">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::normalvariate</a> ()</td></tr>
<tr class="memdesc:gaa9f450e514e0e2f811a3423e78b6bfba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normal distribution (mean=0.0, stdev=1.0).  <br /></td></tr>
<tr class="memitem:ga42ebf72a2ed001bf641c314bcc838c4f" id="r_ga42ebf72a2ed001bf641c314bcc838c4f"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga42ebf72a2ed001bf641c314bcc838c4f">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::normalvariate</a> (const double mu, const double sigma)</td></tr>
<tr class="memdesc:ga42ebf72a2ed001bf641c314bcc838c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normal distribution (mean=mu, stdev=sigma).  <br /></td></tr>
<tr class="memitem:gad1546d1ac18402ada9b5caf724662452" id="r_gad1546d1ac18402ada9b5caf724662452"><td class="memTemplParams" colspan="2">template&lt;typename T, const std::size_t n&gt; </td></tr>
<tr class="memitem:gad1546d1ac18402ada9b5caf724662452 template"><td class="memItemLeft" align="right" valign="top">std::array&lt; T, n &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad1546d1ac18402ada9b5caf724662452">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::operator()</a> (const std::array&lt; T, n &gt; &amp;max)</td></tr>
<tr class="memdesc:gad1546d1ac18402ada9b5caf724662452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Valued call operator (1 std::array of scalars).  <br /></td></tr>
<tr class="memitem:ga6cf4b50aa446a4dcbbd64ac12e91303b" id="r_ga6cf4b50aa446a4dcbbd64ac12e91303b"><td class="memTemplParams" colspan="2">template&lt;typename T, const std::size_t n&gt; </td></tr>
<tr class="memitem:ga6cf4b50aa446a4dcbbd64ac12e91303b template"><td class="memItemLeft" align="right" valign="top">std::array&lt; T, n &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6cf4b50aa446a4dcbbd64ac12e91303b">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::operator()</a> (const std::array&lt; T, n &gt; &amp;min, const std::array&lt; T, n &gt; &amp;max)</td></tr>
<tr class="memdesc:ga6cf4b50aa446a4dcbbd64ac12e91303b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Valued call operator (2 std::array of scalars).  <br /></td></tr>
<tr class="memitem:gad46e92e2c0d88d36ed4e9004374b3eb3" id="r_gad46e92e2c0d88d36ed4e9004374b3eb3"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:gad46e92e2c0d88d36ed4e9004374b3eb3 template"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad46e92e2c0d88d36ed4e9004374b3eb3">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::operator()</a> (const std::vector&lt; T &gt; &amp;max)</td></tr>
<tr class="memdesc:gad46e92e2c0d88d36ed4e9004374b3eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Valued call operator (1 std::vector of scalars).  <br /></td></tr>
<tr class="memitem:ga8b8904245206aa7a8bd6a42e6d3fe8f2" id="r_ga8b8904245206aa7a8bd6a42e6d3fe8f2"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ga8b8904245206aa7a8bd6a42e6d3fe8f2 template"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8b8904245206aa7a8bd6a42e6d3fe8f2">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::operator()</a> (const std::vector&lt; T &gt; &amp;min, const std::vector&lt; T &gt; &amp;max)</td></tr>
<tr class="memdesc:ga8b8904245206aa7a8bd6a42e6d3fe8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Valued call operator (2 std::vector of scalars).  <br /></td></tr>
<tr class="memitem:ga940e175e1dd09f769724a9df85a2287c" id="r_ga940e175e1dd09f769724a9df85a2287c"><td class="memTemplParams" colspan="2">template&lt;typename T = OutputT&gt; </td></tr>
<tr class="memitem:ga940e175e1dd09f769724a9df85a2287c template"><td class="memItemLeft" align="right" valign="top">const T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga940e175e1dd09f769724a9df85a2287c">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::operator()</a> (const T max)</td></tr>
<tr class="memdesc:ga940e175e1dd09f769724a9df85a2287c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Valued call operator (1 scalar).  <br /></td></tr>
<tr class="memitem:ga8a3dd28e28eb5c1214289c9bd9a3ab44" id="r_ga8a3dd28e28eb5c1214289c9bd9a3ab44"><td class="memTemplParams" colspan="2">template&lt;typename T = OutputT&gt; </td></tr>
<tr class="memitem:ga8a3dd28e28eb5c1214289c9bd9a3ab44 template"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8a3dd28e28eb5c1214289c9bd9a3ab44">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::operator()</a> (const T max, const std::size_t n)</td></tr>
<tr class="memdesc:ga8a3dd28e28eb5c1214289c9bd9a3ab44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Valued call operator (max and n scalars).  <br /></td></tr>
<tr class="memitem:ga7016b659c3abe67c5088ea8c64260bb6" id="r_ga7016b659c3abe67c5088ea8c64260bb6"><td class="memTemplParams" colspan="2">template&lt;typename T = OutputT&gt; </td></tr>
<tr class="memitem:ga7016b659c3abe67c5088ea8c64260bb6 template"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7016b659c3abe67c5088ea8c64260bb6">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::operator()</a> (const T min, const T max, const std::size_t n)</td></tr>
<tr class="memdesc:ga7016b659c3abe67c5088ea8c64260bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Valued call operator (min, max and n scalars).  <br /></td></tr>
<tr class="memitem:gacb4a9942b0dd52228a8c643c102c7add" id="r_gacb4a9942b0dd52228a8c643c102c7add"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacb4a9942b0dd52228a8c643c102c7add">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::paretovariate</a> (const double alpha)</td></tr>
<tr class="memdesc:gacb4a9942b0dd52228a8c643c102c7add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pareto distribution.  <br /></td></tr>
<tr class="memitem:ga8e440e69c5e943e85f8fd778deebb92b" id="r_ga8e440e69c5e943e85f8fd778deebb92b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8e440e69c5e943e85f8fd778deebb92b">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::randbytes</a> (const std::size_t n)</td></tr>
<tr class="memdesc:ga8e440e69c5e943e85f8fd778deebb92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates n random bytes.  <br /></td></tr>
<tr class="memitem:ga2c64096931dc07b192f92c131c2cb047" id="r_ga2c64096931dc07b192f92c131c2cb047"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ga2c64096931dc07b192f92c131c2cb047 template"><td class="memItemLeft" align="right" valign="top">const T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2c64096931dc07b192f92c131c2cb047">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::randint</a> (const T a, const T b)</td></tr>
<tr class="memdesc:ga2c64096931dc07b192f92c131c2cb047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns random integer in range [a, b], including both end points.  <br /></td></tr>
<tr class="memitem:ga7dede5e1baced256563617889aef4b74" id="r_ga7dede5e1baced256563617889aef4b74"><td class="memTemplParams" colspan="2">template&lt;typename T, typename S = T&gt; </td></tr>
<tr class="memitem:ga7dede5e1baced256563617889aef4b74 template"><td class="memItemLeft" align="right" valign="top">const T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7dede5e1baced256563617889aef4b74">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::randrange</a> (const T start, const T stop, const S step=S(1))</td></tr>
<tr class="memdesc:ga7dede5e1baced256563617889aef4b74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random value in range [start, stop) with specified step.  <br /></td></tr>
<tr class="memitem:ga1f4df4281975073a3aac23184c87849b" id="r_ga1f4df4281975073a3aac23184c87849b"><td class="memTemplParams" colspan="2">template&lt;typename T, const std::size_t k, const std::size_t n&gt; </td></tr>
<tr class="memitem:ga1f4df4281975073a3aac23184c87849b template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1f4df4281975073a3aac23184c87849b">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::sample</a> (std::array&lt; T, k &gt; &amp;out, const std::array&lt; T, n &gt; &amp;population)</td></tr>
<tr class="memdesc:ga1f4df4281975073a3aac23184c87849b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chooses k unique random elements from a population sequence. All population elements have same weight for the sampling and are each chosen only once.  <br /></td></tr>
<tr class="memitem:gafc91ea302c18b4dfc1d01580c83d2a9e" id="r_gafc91ea302c18b4dfc1d01580c83d2a9e"><td class="memTemplParams" colspan="2">template&lt;typename T, typename C, const std::size_t k, const std::size_t n&gt; </td></tr>
<tr class="memitem:gafc91ea302c18b4dfc1d01580c83d2a9e template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafc91ea302c18b4dfc1d01580c83d2a9e">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::sample</a> (std::array&lt; T, k &gt; &amp;out, const std::array&lt; T, n &gt; &amp;population, const std::array&lt; C, n &gt; &amp;counts)</td></tr>
<tr class="memdesc:gafc91ea302c18b4dfc1d01580c83d2a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chooses k unique random elements from a population sequence (std::array&lt;&gt;, with counts array).  <br /></td></tr>
<tr class="memitem:ga531781fa555945fc7afdcb1de65eaaa3" id="r_ga531781fa555945fc7afdcb1de65eaaa3"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ga531781fa555945fc7afdcb1de65eaaa3 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga531781fa555945fc7afdcb1de65eaaa3">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::sample</a> (std::vector&lt; T &gt; &amp;out, const std::vector&lt; T &gt; &amp;population, const std::size_t k)</td></tr>
<tr class="memdesc:ga531781fa555945fc7afdcb1de65eaaa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chooses k unique random elements from a population sequence. All population elements have same weight for the sampling and are each chosen only once.  <br /></td></tr>
<tr class="memitem:gac41f603988ac30aadcd9e805f924ad70" id="r_gac41f603988ac30aadcd9e805f924ad70"><td class="memTemplParams" colspan="2">template&lt;typename T, typename C&gt; </td></tr>
<tr class="memitem:gac41f603988ac30aadcd9e805f924ad70 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac41f603988ac30aadcd9e805f924ad70">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::sample</a> (std::vector&lt; T &gt; &amp;out, const std::vector&lt; T &gt; &amp;population, const std::vector&lt; C &gt; &amp;counts, const std::size_t k)</td></tr>
<tr class="memdesc:gac41f603988ac30aadcd9e805f924ad70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chooses k unique random elements from a population sequence (std::vector&lt;&gt;, with counts vector).  <br /></td></tr>
<tr class="memitem:ga80e9f597478c077279c5a126f791d032" id="r_ga80e9f597478c077279c5a126f791d032"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga80e9f597478c077279c5a126f791d032">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::seed</a> () noexcept</td></tr>
<tr class="memdesc:ga80e9f597478c077279c5a126f791d032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes internal state (empty signature).  <br /></td></tr>
<tr class="memitem:ga83c4d1f15cba8c9d5ba92d1234a1ba11" id="r_ga83c4d1f15cba8c9d5ba92d1234a1ba11"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga83c4d1f15cba8c9d5ba92d1234a1ba11">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::seed</a> (const double seed_)</td></tr>
<tr class="memdesc:ga83c4d1f15cba8c9d5ba92d1234a1ba11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initalizes internal state from a double seed.  <br /></td></tr>
<tr class="memitem:ga90bad605714495ec531ffe3f2d57c3b5" id="r_ga90bad605714495ec531ffe3f2d57c3b5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga90bad605714495ec531ffe3f2d57c3b5">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::seed</a> (const int seed_) noexcept</td></tr>
<tr class="memdesc:ga90bad605714495ec531ffe3f2d57c3b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes internal state from a 32-bits signed integer seed.  <br /></td></tr>
<tr class="memitem:ga2d3343e9f37a406a1338103d88b7ec24" id="r_ga2d3343e9f37a406a1338103d88b7ec24"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2d3343e9f37a406a1338103d88b7ec24">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::seed</a> (const long long seed_) noexcept</td></tr>
<tr class="memdesc:ga2d3343e9f37a406a1338103d88b7ec24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes internal state from a 64-bits signed integer seed.  <br /></td></tr>
<tr class="memitem:gacb33118938b2f5036bcd48161f36fb34" id="r_gacb33118938b2f5036bcd48161f36fb34"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacb33118938b2f5036bcd48161f36fb34">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::seed</a> (const long seed_) noexcept</td></tr>
<tr class="memdesc:gacb33118938b2f5036bcd48161f36fb34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes internal state from a 32-bits signed integer seed.  <br /></td></tr>
<tr class="memitem:ga2b3ad383892f59932e792ced6fe9626b" id="r_ga2b3ad383892f59932e792ced6fe9626b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2b3ad383892f59932e792ced6fe9626b">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::seed</a> (const unsigned int seed_) noexcept</td></tr>
<tr class="memdesc:ga2b3ad383892f59932e792ced6fe9626b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes internal state from a 32-bits unsigned integer seed.  <br /></td></tr>
<tr class="memitem:ga9e930fe3a6d8f5db9ebaf0b31af41a91" id="r_ga9e930fe3a6d8f5db9ebaf0b31af41a91"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9e930fe3a6d8f5db9ebaf0b31af41a91">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::seed</a> (const unsigned long long seed_) noexcept</td></tr>
<tr class="memdesc:ga9e930fe3a6d8f5db9ebaf0b31af41a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes internal state from a 64-bits unsigned integer seed.  <br /></td></tr>
<tr class="memitem:gac9cb17b7537a45c9fe06c8c03ba86c00" id="r_gac9cb17b7537a45c9fe06c8c03ba86c00"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac9cb17b7537a45c9fe06c8c03ba86c00">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::seed</a> (const unsigned long seed_) noexcept</td></tr>
<tr class="memdesc:gac9cb17b7537a45c9fe06c8c03ba86c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes internal state from a 32-bits unsigned integer seed.  <br /></td></tr>
<tr class="memitem:gaa6d9794a49bc5c6f0639f9c235cc4183" id="r_gaa6d9794a49bc5c6f0639f9c235cc4183"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa6d9794a49bc5c6f0639f9c235cc4183">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::seed</a> (const <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a> &amp;seed_) noexcept</td></tr>
<tr class="memdesc:gaa6d9794a49bc5c6f0639f9c235cc4183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the internal state of this PRNG with a 128-bits integer seed.  <br /></td></tr>
<tr class="memitem:ga567817c5860bb6d7fb498e5ada646d84" id="r_ga567817c5860bb6d7fb498e5ada646d84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga567817c5860bb6d7fb498e5ada646d84">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::setstate</a> (const StateT &amp;new_internal_state) noexcept</td></tr>
<tr class="memdesc:ga567817c5860bb6d7fb498e5ada646d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the internal state from a new internal state content.  <br /></td></tr>
<tr class="memitem:ga352fcb0394b588ed1419a08e20184184" id="r_ga352fcb0394b588ed1419a08e20184184"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga352fcb0394b588ed1419a08e20184184">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::setstate</a> (const StateT &amp;new_internal_state, const double gauss_next) noexcept</td></tr>
<tr class="memdesc:ga352fcb0394b588ed1419a08e20184184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the internal state from a new internal state content and with gauss_next.  <br /></td></tr>
<tr class="memitem:ga3f4cd3ee32d5c3afaca67a51120fa62a" id="r_ga3f4cd3ee32d5c3afaca67a51120fa62a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3f4cd3ee32d5c3afaca67a51120fa62a">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::setstate</a> (const struct <a class="el" href="struct_base_random_1_1___internal_state.html">_InternalState</a> &amp;new_internal_state) noexcept</td></tr>
<tr class="memdesc:ga3f4cd3ee32d5c3afaca67a51120fa62a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restores internal state from object returned by <a class="el" href="class_base_random.html#ad3504565dc9bd81a27af0e00a27eeb83" title="Returns the internal state of this PRNG; can be passed to setstate() later.">getstate()</a>.  <br /></td></tr>
<tr class="memitem:gac997a3ddc920dd8b1762a35f28ab59b1" id="r_gac997a3ddc920dd8b1762a35f28ab59b1"><td class="memTemplParams" colspan="2">template&lt;typename ContainerType&gt; </td></tr>
<tr class="memitem:gac997a3ddc920dd8b1762a35f28ab59b1 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac997a3ddc920dd8b1762a35f28ab59b1">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::shuffle</a> (ContainerType &amp;seq)</td></tr>
<tr class="memdesc:gac997a3ddc920dd8b1762a35f28ab59b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuffles specified sequence in place.  <br /></td></tr>
<tr class="memitem:gaa229184903dab58744e3b44c09060060" id="r_gaa229184903dab58744e3b44c09060060"><td class="memItemLeft" align="right" valign="top">const state_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa229184903dab58744e3b44c09060060">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::state</a> () const noexcept</td></tr>
<tr class="memdesc:gaa229184903dab58744e3b44c09060060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current internal state value.  <br /></td></tr>
<tr class="memitem:gad52918dd3d5d0231e67d8f6068f5415c" id="r_gad52918dd3d5d0231e67d8f6068f5415c"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad52918dd3d5d0231e67d8f6068f5415c">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::triangular</a> () noexcept</td></tr>
<tr class="memdesc:gad52918dd3d5d0231e67d8f6068f5415c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangular distribution (low=0.0, high=1.0, mode=0.5).  <br /></td></tr>
<tr class="memitem:ga5a885e2900639157c1d4303a8341d773" id="r_ga5a885e2900639157c1d4303a8341d773"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5a885e2900639157c1d4303a8341d773">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::triangular</a> (const double low, const double high) noexcept</td></tr>
<tr class="memdesc:ga5a885e2900639157c1d4303a8341d773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangular distribution (low, high, default mode).  <br /></td></tr>
<tr class="memitem:ga0fb0414ad08c26462b8a459063fa500b" id="r_ga0fb0414ad08c26462b8a459063fa500b"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0fb0414ad08c26462b8a459063fa500b">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::triangular</a> (const double low, const double high, const double mode) noexcept</td></tr>
<tr class="memdesc:ga0fb0414ad08c26462b8a459063fa500b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangular distribution (low, high, mode).  <br /></td></tr>
<tr class="memitem:gaca1fbb47b8f64989f590db78a46c3dc9" id="r_gaca1fbb47b8f64989f590db78a46c3dc9"><td class="memTemplParams" colspan="2">template&lt;typename T = double&gt; </td></tr>
<tr class="memitem:gaca1fbb47b8f64989f590db78a46c3dc9 template"><td class="memItemLeft" align="right" valign="top">const T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaca1fbb47b8f64989f590db78a46c3dc9">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::uniform</a> ()</td></tr>
<tr class="memdesc:gaca1fbb47b8f64989f590db78a46c3dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uniform distribution in [0.0, 1.0).  <br /></td></tr>
<tr class="memitem:gac890696338ca27009a01ed05f57d2fab" id="r_gac890696338ca27009a01ed05f57d2fab"><td class="memTemplParams" colspan="2">template&lt;typename T = double, typename U = T&gt; </td></tr>
<tr class="memitem:gac890696338ca27009a01ed05f57d2fab template"><td class="memItemLeft" align="right" valign="top">const T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac890696338ca27009a01ed05f57d2fab">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::uniform</a> (const U max)</td></tr>
<tr class="memdesc:gac890696338ca27009a01ed05f57d2fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uniform distribution in [0.0, max).  <br /></td></tr>
<tr class="memitem:ga97883d666a37d5a7a9dddd639c38a6d0" id="r_ga97883d666a37d5a7a9dddd639c38a6d0"><td class="memTemplParams" colspan="2">template&lt;typename T, typename U = T, typename V = U&gt; </td></tr>
<tr class="memitem:ga97883d666a37d5a7a9dddd639c38a6d0 template"><td class="memItemLeft" align="right" valign="top">const T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga97883d666a37d5a7a9dddd639c38a6d0">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::uniform</a> (const U min, const V max)</td></tr>
<tr class="memdesc:ga97883d666a37d5a7a9dddd639c38a6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uniform distribution in [min, max).  <br /></td></tr>
<tr class="memitem:gaa25fa3e19ed9f51a06cb88c95d405916" id="r_gaa25fa3e19ed9f51a06cb88c95d405916"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa25fa3e19ed9f51a06cb88c95d405916">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::vonmisesvariate</a> (const double mu, const double kappa)</td></tr>
<tr class="memdesc:gaa25fa3e19ed9f51a06cb88c95d405916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Circular data distribution.  <br /></td></tr>
<tr class="memitem:ga9f05337da61ce6f92cc9adb25f6d6224" id="r_ga9f05337da61ce6f92cc9adb25f6d6224"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9f05337da61ce6f92cc9adb25f6d6224">BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::weibullvariate</a> (const double alpha, const double beta)</td></tr>
<tr class="memdesc:ga9f05337da61ce6f92cc9adb25f6d6224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weibull distribution.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga0ce0aba3610046d25961f2bd1e5f776e" id="r_ga0ce0aba3610046d25961f2bd1e5f776e"><td class="memTemplParams" colspan="2"><a id="ga0ce0aba3610046d25961f2bd1e5f776e" name="ga0ce0aba3610046d25961f2bd1e5f776e"></a>
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </td></tr>
<tr class="memitem:ga0ce0aba3610046d25961f2bd1e5f776e template"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><b>BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::BPF</b> { 53 }</td></tr>
<tr class="memitem:ga1b1379b01a36be483ca9b7c922c22a27" id="r_ga1b1379b01a36be483ca9b7c922c22a27"><td class="memTemplParams" colspan="2"><a id="ga1b1379b01a36be483ca9b7c922c22a27" name="ga1b1379b01a36be483ca9b7c922c22a27"></a>
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </td></tr>
<tr class="memitem:ga1b1379b01a36be483ca9b7c922c22a27 template"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><b>BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::E</b> { std::exp(1.0) }</td></tr>
<tr class="memitem:gaafb930a3cc32c0c0bbb966a89a7ebced" id="r_gaafb930a3cc32c0c0bbb966a89a7ebced"><td class="memTemplParams" colspan="2"><a id="gaafb930a3cc32c0c0bbb966a89a7ebced" name="gaafb930a3cc32c0c0bbb966a89a7ebced"></a>
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </td></tr>
<tr class="memitem:gaafb930a3cc32c0c0bbb966a89a7ebced template"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><b>BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::GAUSS_NULL</b> = -1.0</td></tr>
<tr class="memitem:ga8aba9709768420d2e1f6818e45ce7b81" id="r_ga8aba9709768420d2e1f6818e45ce7b81"><td class="memTemplParams" colspan="2"><a id="ga8aba9709768420d2e1f6818e45ce7b81" name="ga8aba9709768420d2e1f6818e45ce7b81"></a>
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </td></tr>
<tr class="memitem:ga8aba9709768420d2e1f6818e45ce7b81 template"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><b>BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::LOG4</b> { std::log(4.0) }</td></tr>
<tr class="memitem:gafa9c044d636b93b9c92ec534081bca30" id="r_gafa9c044d636b93b9c92ec534081bca30"><td class="memTemplParams" colspan="2"><a id="gafa9c044d636b93b9c92ec534081bca30" name="gafa9c044d636b93b9c92ec534081bca30"></a>
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </td></tr>
<tr class="memitem:gafa9c044d636b93b9c92ec534081bca30 template"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><b>BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::NV_MAGICCONST</b> { 4 * std::exp(-0.5) / std::sqrt(2.0) }</td></tr>
<tr class="memitem:ga117c9dde68944b76fc58faa87c62b9ac" id="r_ga117c9dde68944b76fc58faa87c62b9ac"><td class="memTemplParams" colspan="2"><a id="ga117c9dde68944b76fc58faa87c62b9ac" name="ga117c9dde68944b76fc58faa87c62b9ac"></a>
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </td></tr>
<tr class="memitem:ga117c9dde68944b76fc58faa87c62b9ac template"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><b>BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::PI</b> { 3.14159265358979323846 }</td></tr>
<tr class="memitem:ga30c2bc68148b3587db28f4558cbbb05d" id="r_ga30c2bc68148b3587db28f4558cbbb05d"><td class="memTemplParams" colspan="2"><a id="ga30c2bc68148b3587db28f4558cbbb05d" name="ga30c2bc68148b3587db28f4558cbbb05d"></a>
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </td></tr>
<tr class="memitem:ga30c2bc68148b3587db28f4558cbbb05d template"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><b>BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::RECIP_BPF</b> { std::exp2(-BPF) }</td></tr>
<tr class="memitem:gad7560b1892cf36741c258e7a13b68179" id="r_gad7560b1892cf36741c258e7a13b68179"><td class="memTemplParams" colspan="2"><a id="gad7560b1892cf36741c258e7a13b68179" name="gad7560b1892cf36741c258e7a13b68179"></a>
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </td></tr>
<tr class="memitem:gad7560b1892cf36741c258e7a13b68179 template"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><b>BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::SG_MAGICCONST</b> { 1.0 + std::log(4.5) }</td></tr>
<tr class="memitem:gad3bfb9119da4dc05e3c85cdd76a54094" id="r_gad3bfb9119da4dc05e3c85cdd76a54094"><td class="memTemplParams" colspan="2"><a id="gad3bfb9119da4dc05e3c85cdd76a54094" name="gad3bfb9119da4dc05e3c85cdd76a54094"></a>
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </td></tr>
<tr class="memitem:gad3bfb9119da4dc05e3c85cdd76a54094 template"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><b>BaseRandom&lt; StateT, OutputT, OUTPUT_BITS &gt;::TWO_PI</b> { 2.0 * <a class="el" href="class_base_random.html">BaseRandom</a>&lt;StateT, OutputT, OUTPUT_BITS&gt;::PI }</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<p>This is the definition of the base class for all pseudo-random numbers generators that are implemented in CppRandLib. </p>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="gaed12b45277ba1dc14ceee61f26f2ef40" name="gaed12b45277ba1dc14ceee61f26f2ef40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed12b45277ba1dc14ceee61f26f2ef40">&#9670;&#160;</a></span>betavariate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const double <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::betavariate </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Beta distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>double, must be greater than 0 </td></tr>
    <tr><td class="paramname">beta</td><td>double, must be greater than 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a value in interval [0.0, 1.0].</dd></dl>
<p>Important notice: the implemented code is a translation from Python <a href="https://github.com/python/cpython/blob/3.11/Lib/random.py">https://github.com/python/cpython/blob/3.11/Lib/random.py</a> into c++. The original code is due to Janne Sinkkonen and matches all the std texts (e.g., Knuth Vol 2 Ed 3 pg 134 "the beta distribution").</p>
<p>Beta distribution. </p>

<p class="reference">References <a class="el" href="#ga3d1130df7b8d9630100c810088206596">gammavariate()</a>.</p>

</div>
</div>
<a id="gafc4b4494902512708c6611366b41044d" name="gafc4b4494902512708c6611366b41044d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc4b4494902512708c6611366b41044d">&#9670;&#160;</a></span>binomialvariate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<div class="memtemplate">
template&lt;typename CountT, typename ProbaT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const CountT <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::binomialvariate </td>
          <td>(</td>
          <td class="paramtype">CountT</td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ProbaT</td>          <td class="paramname"><span class="paramname"><em>p</em></span><span class="paramdefsep"> = </span><span class="paramdefval">ProbaT(0.5)</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of successes for n&gt;=0 independent trials. </p>
<p>Returns the number of successes for n&gt;=0 independent trials. </p>

<p class="reference">References <a class="el" href="#gaca1fbb47b8f64989f590db78a46c3dc9">uniform()</a>.</p>

</div>
</div>
<a id="gaea6eb3e08499a26f9ea65250fcf83c19" name="gaea6eb3e08499a26f9ea65250fcf83c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea6eb3e08499a26f9ea65250fcf83c19">&#9670;&#160;</a></span>choice() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<div class="memtemplate">
template&lt;typename T, const std::size_t n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::choice </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, n &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>seq</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chooses a random element from a non-empty sequence (std::array). </p>
<p>Chooses a random element from a non-empty sequence (std::array). </p>

<p class="reference">References <a class="el" href="#gaca1fbb47b8f64989f590db78a46c3dc9">uniform()</a>.</p>

</div>
</div>
<a id="gad4d317c0bb6478aab7598b18659eec07" name="gad4d317c0bb6478aab7598b18659eec07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4d317c0bb6478aab7598b18659eec07">&#9670;&#160;</a></span>choice() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::choice </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>seq</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chooses a random element from a non-empty sequence (std::vector). </p>
<p>Chooses a random element from a non-empty sequence (std::vector). </p>

<p class="reference">References <a class="el" href="#gaca1fbb47b8f64989f590db78a46c3dc9">uniform()</a>.</p>

</div>
</div>
<a id="ga4142d2e866225a4ef30f79d90ffa88ba" name="ga4142d2e866225a4ef30f79d90ffa88ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4142d2e866225a4ef30f79d90ffa88ba">&#9670;&#160;</a></span>choices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::choices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>population</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>k</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a k sized vector of elements chosen from the population with replacement (same weights). </p>
<p>Returns a k sized vector of elements chosen from the population with replacement (same weights). </p>

<p class="reference">References <a class="el" href="#gac51f62e6a02a9f2d0084f0ce22a07f18">choices_cum()</a>.</p>

</div>
</div>
<a id="ga55fb36e312a372d16b339b639b149632" name="ga55fb36e312a372d16b339b639b149632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55fb36e312a372d16b339b639b149632">&#9670;&#160;</a></span>choices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<div class="memtemplate">
template&lt;typename T, typename C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::choices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>population</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; C &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>weights</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>k</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a k sized vector of elements chosen from the population with replacement (individual weights). </p>
<p>Returns a k sized vector of elements chosen from the population with replacement (individual weights). </p>

<p class="reference">References <a class="el" href="#gac51f62e6a02a9f2d0084f0ce22a07f18">choices_cum()</a>.</p>

</div>
</div>
<a id="gac51f62e6a02a9f2d0084f0ce22a07f18" name="gac51f62e6a02a9f2d0084f0ce22a07f18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac51f62e6a02a9f2d0084f0ce22a07f18">&#9670;&#160;</a></span>choices_cum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<div class="memtemplate">
template&lt;typename T, typename C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::choices_cum </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>population</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; C &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cum_weights</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>k</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a k sized vector of elements chosen from the population with replacement (cumulative weights). </p>
<p>Returns a k sized vector of elements chosen from the population with replacement (cumulative weights). </p>

<p class="reference">Referenced by <a class="el" href="#ga4142d2e866225a4ef30f79d90ffa88ba">choices()</a>, and <a class="el" href="#ga55fb36e312a372d16b339b639b149632">choices()</a>.</p>

</div>
</div>
<a id="ga18d7abf6f8898fb186eced8d8db6c40c" name="ga18d7abf6f8898fb186eced8d8db6c40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18d7abf6f8898fb186eced8d8db6c40c">&#9670;&#160;</a></span>expovariate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const double <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::expovariate </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>lambda</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exponential distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lambda</td><td>double, this should get the value (1.0 / desired_mean). It cannot be 0.0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a value in range [0.0, Infinity) if lambda is positive, or a value in range (-Infinity, 0.0] if lambda is negative.</dd></dl>
<p>Important notice: the implemented code is a translation from Python <a href="https://github.com/python/cpython/blob/3.11/Lib/random.py">https://github.com/python/cpython/blob/3.11/Lib/random.py</a> into c++.</p>
<p>Exponential distribution. </p>

<p class="reference">References <a class="el" href="#gaca1fbb47b8f64989f590db78a46c3dc9">uniform()</a>.</p>

</div>
</div>
<a id="ga3d1130df7b8d9630100c810088206596" name="ga3d1130df7b8d9630100c810088206596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d1130df7b8d9630100c810088206596">&#9670;&#160;</a></span>gammavariate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const double <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::gammavariate </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gamma distribution. This is NOT the gamma function! </p>
<p>The probability distribution function is : x^(alpha - 1) * std::exp(-x / beta) pdf(x) = --------------------------------&mdash; std::tgamma(alpha) * beta^alpha where: pdf is the probability density function a^b is std::pow(a, b) std::tgamma() is the Gamma funtion as implemented in the c++ math library.</p>
<p>The Gamma function is the below integral summation from 0 to Infinity: Γ(x) = ∫0∞ t^(x−1) * std::exp(−t) dt</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>: double, the shape parameter - must be greater than 0.0. </td></tr>
    <tr><td class="paramname">beta</td><td>: double, the scale parameter - must be greater than 0.0. With these two arguments: mean is alpha * beta and variance is alpha * beta * beta</td></tr>
  </table>
  </dd>
</dl>
<p>Important notice: the implemented code is a translation from Python <a href="https://github.com/python/cpython/blob/3.11/Lib/random.py">https://github.com/python/cpython/blob/3.11/Lib/random.py</a> into c++. As such, some comments present in the Python original code have been copied as is in this c++ implementation, naming then the authors of the related parts of code.</p>
<p>Gamma distribution. This is NOT the gamma function! </p>

<p class="reference">References <a class="el" href="#gaca1fbb47b8f64989f590db78a46c3dc9">uniform()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#gaed12b45277ba1dc14ceee61f26f2ef40">betavariate()</a>.</p>

</div>
</div>
<a id="ga8a666db0bc34218dd06f633f94644f15" name="ga8a666db0bc34218dd06f633f94644f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a666db0bc34218dd06f633f94644f15">&#9670;&#160;</a></span>gauss() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::gauss </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default Gaussian distribution (mean=0.0, stdev=1.0). </p>
<p>This is slightly faster than the <a class="el" href="#gaa9f450e514e0e2f811a3423e78b6bfba" title="Normal distribution (mean=0.0, stdev=1.0).">normalvariate()</a> function. Notice: not thread-safe without a lock around calls.</p>
<p>Important notice: the implemented code is a translation from Python <a href="https://github.com/python/cpython/blob/3.11/Lib/random.py">https://github.com/python/cpython/blob/3.11/Lib/random.py</a> into c++.</p>
<p>Default Gaussian distribution (mean=0.0, stdev=1.0). </p>

<p class="reference">References <a class="el" href="#ga8a666db0bc34218dd06f633f94644f15">gauss()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#ga8a666db0bc34218dd06f633f94644f15">gauss()</a>.</p>

</div>
</div>
<a id="gae879ae952c45bad110e45a671fafed3d" name="gae879ae952c45bad110e45a671fafed3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae879ae952c45bad110e45a671fafed3d">&#9670;&#160;</a></span>gauss() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const double <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::gauss </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>mu</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>sigma</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gaussian distribution (mean=mu, stdev=sigma). </p>
<p>mu is the mean, and sigma is the standard deviation. mu can be any value, sigma must be greater than 0.0. This is slightly faster than the <a class="el" href="#gaa9f450e514e0e2f811a3423e78b6bfba" title="Normal distribution (mean=0.0, stdev=1.0).">normalvariate()</a> function.</p>
<p>Notice: not thread-safe without a mutex around calls.</p>
<p>Important notice: the implemented code is a translation from Python <a href="https://github.com/python/cpython/blob/3.11/Lib/random.py">https://github.com/python/cpython/blob/3.11/Lib/random.py</a> into c++.</p>
<p>Gaussian distribution (mean=mu, stdev=sigma). </p>

<p class="reference">References <a class="el" href="#gaca1fbb47b8f64989f590db78a46c3dc9">uniform()</a>.</p>

</div>
</div>
<a id="ga3eb4a34360f955c70c94c2bb551e456d" name="ga3eb4a34360f955c70c94c2bb551e456d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3eb4a34360f955c70c94c2bb551e456d">&#9670;&#160;</a></span>lognormvariate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::lognormvariate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default Log normal distribution (mean=0.0, stdev=1.0). </p>
<p>If you take the natural logarithm of this distribution, you'll get a normal distribution with mean 0.0 and standard deviation 1.0.</p>
<p>Important notice: the implemented code is a translation from Python <a href="https://github.com/python/cpython/blob/3.11/Lib/random.py">https://github.com/python/cpython/blob/3.11/Lib/random.py</a> into c++.</p>
<p>Default Log normal distribution (mean=0.0, stdev=1.0). </p>

<p class="reference">References <a class="el" href="#ga3eb4a34360f955c70c94c2bb551e456d">lognormvariate()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#ga3eb4a34360f955c70c94c2bb551e456d">lognormvariate()</a>.</p>

</div>
</div>
<a id="ga72f98396e7045aead22be7a676071ee4" name="ga72f98396e7045aead22be7a676071ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72f98396e7045aead22be7a676071ee4">&#9670;&#160;</a></span>lognormvariate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::lognormvariate </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>mu</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>sigma</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Log normal distribution (mean=mu, stdev=sigma). </p>
<p>If you take the natural logarithm of this distribution, you'll get a normal distribution with mean mu and standard deviation sigma. mu can have any value, and sigma must be greater than zero.</p>
<p>Important notice: the implemented code is a translation from Python <a href="https://github.com/python/cpython/blob/3.11/Lib/random.py">https://github.com/python/cpython/blob/3.11/Lib/random.py</a> into c++.</p>
<p>Log normal distribution (mean=mu, stdev=sigma). </p>

<p class="reference">References <a class="el" href="#gaa9f450e514e0e2f811a3423e78b6bfba">normalvariate()</a>.</p>

</div>
</div>
<a id="gac17bfe15bfc24f45f332600c509af0bf" name="gac17bfe15bfc24f45f332600c509af0bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac17bfe15bfc24f45f332600c509af0bf">&#9670;&#160;</a></span>n_evaluate() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<div class="memtemplate">
template&lt;typename T, const std::size_t n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, n &gt; <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::n_evaluate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an array of n values that are uniformly contained within range [0.0, 1.0). </p>
<p>Returns an array of n values that are uniformly contained within range [0.0, 1.0). </p>

<p class="reference">References <a class="el" href="#gaca1fbb47b8f64989f590db78a46c3dc9">uniform()</a>.</p>

</div>
</div>
<a id="gaa6e2821e442bde7866f82bbc5edc198b" name="gaa6e2821e442bde7866f82bbc5edc198b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6e2821e442bde7866f82bbc5edc198b">&#9670;&#160;</a></span>n_evaluate() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<div class="memtemplate">
template&lt;typename T, const std::size_t m, typename U, const std::size_t n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, m &gt; <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::n_evaluate </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; U, n &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>max</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an array of min(m, n) values in range [0; max[i]). </p>
<p>Returns an array of min(m, n) values in range [0; max[i]). </p>

<p class="reference">References <a class="el" href="#gaca1fbb47b8f64989f590db78a46c3dc9">uniform()</a>.</p>

</div>
</div>
<a id="ga6ca752783b82acd4e8f9234eb4d60457" name="ga6ca752783b82acd4e8f9234eb4d60457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ca752783b82acd4e8f9234eb4d60457">&#9670;&#160;</a></span>n_evaluate() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<div class="memtemplate">
template&lt;typename T, const std::size_t m, typename U, const std::size_t n, typename V, const std::size_t p&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, m &gt; <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::n_evaluate </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; U, n &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; V, p &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>max</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an array min(m, n, p) values in range [min[i]; max[i]). </p>
<p>Returns an array min(m, n, p) values in range [min[i]; max[i]). </p>

<p class="reference">References <a class="el" href="#gaca1fbb47b8f64989f590db78a46c3dc9">uniform()</a>.</p>

</div>
</div>
<a id="ga9102cc1375bafb0167d07137d666fd21" name="ga9102cc1375bafb0167d07137d666fd21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9102cc1375bafb0167d07137d666fd21">&#9670;&#160;</a></span>n_evaluate() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::n_evaluate </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector of n values that are uniformly contained within range [0.0, 1.0). </p>
<p>Returns a vector of n values that are uniformly contained within range [0.0, 1.0). </p>

</div>
</div>
<a id="gada9e29de5440f3630cc1ed1200c2addc" name="gada9e29de5440f3630cc1ed1200c2addc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada9e29de5440f3630cc1ed1200c2addc">&#9670;&#160;</a></span>n_evaluate() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<div class="memtemplate">
template&lt;typename T, typename U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::n_evaluate </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>max</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of n values that are uniformly contained within range [0, max). </p>
<p>Returns a vector of n values that are uniformly contained within range [0, max). </p>

<p class="reference">References <a class="el" href="#gaca1fbb47b8f64989f590db78a46c3dc9">uniform()</a>.</p>

</div>
</div>
<a id="ga0bbf20019058e6c797ed16a66cb0e276" name="ga0bbf20019058e6c797ed16a66cb0e276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bbf20019058e6c797ed16a66cb0e276">&#9670;&#160;</a></span>n_evaluate() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<div class="memtemplate">
template&lt;typename T, typename U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::n_evaluate </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>max</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of n values in range [0; max[i]). </p>
<p>Returns a vector of n values in range [0; max[i]). </p>

<p class="reference">References <a class="el" href="#gaca1fbb47b8f64989f590db78a46c3dc9">uniform()</a>.</p>

</div>
</div>
<a id="ga806d5a87c263b5d46b6aca1653b9e713" name="ga806d5a87c263b5d46b6aca1653b9e713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga806d5a87c263b5d46b6aca1653b9e713">&#9670;&#160;</a></span>n_evaluate() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<div class="memtemplate">
template&lt;typename T, typename U, typename V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::n_evaluate </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; V &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>max</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of n values in range [min[i]; max[i]). </p>
<p>Returns a vector of n values in range [min[i]; max[i]). </p>

<p class="reference">References <a class="el" href="#gaca1fbb47b8f64989f590db78a46c3dc9">uniform()</a>.</p>

</div>
</div>
<a id="ga17f2c7bc2d2887b512a06c70eeb901f2" name="ga17f2c7bc2d2887b512a06c70eeb901f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17f2c7bc2d2887b512a06c70eeb901f2">&#9670;&#160;</a></span>n_evaluate() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<div class="memtemplate">
template&lt;typename T, const std::size_t n, typename U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, n &gt; <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::n_evaluate </td>
          <td>(</td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>max</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an array of n values that are uniformly contained within range [0, max). </p>
<p>Returns an array of n values that are uniformly contained within range [0, max). </p>

<p class="reference">References <a class="el" href="#gaca1fbb47b8f64989f590db78a46c3dc9">uniform()</a>.</p>

</div>
</div>
<a id="ga68ef9857c13f946fa36bcde40a44b5f5" name="ga68ef9857c13f946fa36bcde40a44b5f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68ef9857c13f946fa36bcde40a44b5f5">&#9670;&#160;</a></span>n_evaluate() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<div class="memtemplate">
template&lt;typename T, const std::size_t n, typename U, typename V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, n &gt; <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::n_evaluate </td>
          <td>(</td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V</td>          <td class="paramname"><span class="paramname"><em>max</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an array of n values that are uniformly contained within range [min, max). </p>
<p>Returns an array of n values that are uniformly contained within range [min, max). </p>

<p class="reference">References <a class="el" href="#gaca1fbb47b8f64989f590db78a46c3dc9">uniform()</a>.</p>

</div>
</div>
<a id="gaa9f450e514e0e2f811a3423e78b6bfba" name="gaa9f450e514e0e2f811a3423e78b6bfba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9f450e514e0e2f811a3423e78b6bfba">&#9670;&#160;</a></span>normalvariate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::normalvariate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normal distribution (mean=0.0, stdev=1.0). </p>
<p>The Python version of this method uses Kindermanand Monahan method. Reference: Kinderman, A.J.and Monahan, J.F., "Computer generation of 
random variables using the ratio of  uniform  deviates", ACM Trans Math Software, 3, (1977), pp257 - 260. This method is slightlly slower than the gauss method. Furthermore, we've s lightly modified the original algorithm here to fulfill very special cases that might happen in very specific conditions. This slows down also the running of <a class="el" href="#gaa9f450e514e0e2f811a3423e78b6bfba" title="Normal distribution (mean=0.0, stdev=1.0).">normalvariate()</a> in these very specific conditions. You should prefer then to use method <a class="el" href="#ga8a666db0bc34218dd06f633f94644f15" title="Default Gaussian distribution (mean=0.0, stdev=1.0).">gauss()</a> instead of this one.</p>
<p>Important notice: the implemented code is a translation from Python <a href="https://github.com/python/cpython/blob/3.11/Lib/random.py">https://github.com/python/cpython/blob/3.11/Lib/random.py</a> into c++.</p>
<p>Normal distribution (mean=0.0, stdev=1.0). </p>

<p class="reference">References <a class="el" href="#gaa9f450e514e0e2f811a3423e78b6bfba">normalvariate()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#ga72f98396e7045aead22be7a676071ee4">lognormvariate()</a>, and <a class="el" href="#gaa9f450e514e0e2f811a3423e78b6bfba">normalvariate()</a>.</p>

</div>
</div>
<a id="ga42ebf72a2ed001bf641c314bcc838c4f" name="ga42ebf72a2ed001bf641c314bcc838c4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42ebf72a2ed001bf641c314bcc838c4f">&#9670;&#160;</a></span>normalvariate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::normalvariate </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>mu</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>sigma</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normal distribution (mean=mu, stdev=sigma). </p>
<p>mu is the mean, and sigma is the standard deviation. mu can be any value, sigma must be greater than 0.0.</p>
<p>The Python version of this method uses Kindermanand Monahan method. Reference: Kinderman, A.J.and Monahan, J.F., "Computer generation of
random variables using the ratio of  uniform  deviates", ACM Trans Math Software, 3, (1977), pp257 - 260. This method is slightlly slower than the gauss method. Furthermore, we've s lightly modified the original algorithm here to fulfill very special cases that might happen in very specific conditions. This slows down also the running of <a class="el" href="#gaa9f450e514e0e2f811a3423e78b6bfba" title="Normal distribution (mean=0.0, stdev=1.0).">normalvariate()</a> in these very specific conditions. You should prefer then to use method <a class="el" href="#ga8a666db0bc34218dd06f633f94644f15" title="Default Gaussian distribution (mean=0.0, stdev=1.0).">gauss()</a> instead of this one.</p>
<p>Important notice: the implemented code is a translation from Python <a href="https://github.com/python/cpython/blob/3.11/Lib/random.py">https://github.com/python/cpython/blob/3.11/Lib/random.py</a> into c++.</p>
<p>Normal distribution (mean=mu, stdev=sigma). </p>

<p class="reference">References <a class="el" href="#gaca1fbb47b8f64989f590db78a46c3dc9">uniform()</a>.</p>

</div>
</div>
<a id="gad1546d1ac18402ada9b5caf724662452" name="gad1546d1ac18402ada9b5caf724662452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1546d1ac18402ada9b5caf724662452">&#9670;&#160;</a></span>operator()() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<div class="memtemplate">
template&lt;typename T, const std::size_t n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, n &gt; <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, n &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>max</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Valued call operator (1 std::array of scalars). </p>
<dl class="section return"><dt>Returns</dt><dd>an array of values that are uniformly contained within the interval [0; max[i]) &ndash; i being the index of the value in the returned array.</dd></dl>
<p>Valued call operator (1 std::array of scalars). </p>

<p class="reference">References <a class="el" href="#gaca1fbb47b8f64989f590db78a46c3dc9">uniform()</a>.</p>

</div>
</div>
<a id="ga6cf4b50aa446a4dcbbd64ac12e91303b" name="ga6cf4b50aa446a4dcbbd64ac12e91303b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cf4b50aa446a4dcbbd64ac12e91303b">&#9670;&#160;</a></span>operator()() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<div class="memtemplate">
template&lt;typename T, const std::size_t n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, n &gt; <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, n &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, n &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>max</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Valued call operator (2 std::array of scalars). </p>
<dl class="section return"><dt>Returns</dt><dd>an array of values that are uniformly contained within the interval [min[i]; max[i]) - i being the index of the value in the returned array.</dd></dl>
<p>Valued call operator (2 std::array of scalars). </p>

<p class="reference">References <a class="el" href="#gaca1fbb47b8f64989f590db78a46c3dc9">uniform()</a>.</p>

</div>
</div>
<a id="gad46e92e2c0d88d36ed4e9004374b3eb3" name="gad46e92e2c0d88d36ed4e9004374b3eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad46e92e2c0d88d36ed4e9004374b3eb3">&#9670;&#160;</a></span>operator()() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>max</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Valued call operator (1 std::vector of scalars). </p>
<dl class="section return"><dt>Returns</dt><dd>a vector of values that are uniformly contained within the interval [0; max[i]) &ndash; i being the index of the value in the returned vector.</dd></dl>
<p>Valued call operator (1 std::vector of scalars). </p>

<p class="reference">References <a class="el" href="#gaca1fbb47b8f64989f590db78a46c3dc9">uniform()</a>.</p>

</div>
</div>
<a id="ga8b8904245206aa7a8bd6a42e6d3fe8f2" name="ga8b8904245206aa7a8bd6a42e6d3fe8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b8904245206aa7a8bd6a42e6d3fe8f2">&#9670;&#160;</a></span>operator()() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>max</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Valued call operator (2 std::vector of scalars). </p>
<dl class="section return"><dt>Returns</dt><dd>a vector of values that are uniformly contained within the interval [min[i]; max[i]) - i being the index of the value in the returned vector.</dd></dl>
<p>Valued call operator (2 std::vector of scalars). </p>

<p class="reference">References <a class="el" href="#gaca1fbb47b8f64989f590db78a46c3dc9">uniform()</a>.</p>

</div>
</div>
<a id="ga940e175e1dd09f769724a9df85a2287c" name="ga940e175e1dd09f769724a9df85a2287c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga940e175e1dd09f769724a9df85a2287c">&#9670;&#160;</a></span>operator()() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>max</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Valued call operator (1 scalar). </p>
<dl class="section return"><dt>Returns</dt><dd>a value that is uniformly contained within range [0; max).</dd></dl>
<p>Valued call operator (1 scalar). </p>

<p class="reference">References <a class="el" href="#gaca1fbb47b8f64989f590db78a46c3dc9">uniform()</a>.</p>

</div>
</div>
<a id="ga8a3dd28e28eb5c1214289c9bd9a3ab44" name="ga8a3dd28e28eb5c1214289c9bd9a3ab44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a3dd28e28eb5c1214289c9bd9a3ab44">&#9670;&#160;</a></span>operator()() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>max</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Valued call operator (max and n scalars). </p>
<dl class="section return"><dt>Returns</dt><dd>a vector of n values that are uniformly contained within range [0; max).</dd></dl>
<p>Valued call operator (max and n scalars). </p>

<p class="reference">References <a class="el" href="#gaca1fbb47b8f64989f590db78a46c3dc9">uniform()</a>.</p>

</div>
</div>
<a id="ga7016b659c3abe67c5088ea8c64260bb6" name="ga7016b659c3abe67c5088ea8c64260bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7016b659c3abe67c5088ea8c64260bb6">&#9670;&#160;</a></span>operator()() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>max</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Valued call operator (min, max and n scalars). </p>
<dl class="section return"><dt>Returns</dt><dd>a vector of n values that are uniformly contained within range [min; max).</dd></dl>
<p>Valued call operator (min, max and n scalars). </p>

<p class="reference">References <a class="el" href="#gaca1fbb47b8f64989f590db78a46c3dc9">uniform()</a>.</p>

</div>
</div>
<a id="gacb4a9942b0dd52228a8c643c102c7add" name="gacb4a9942b0dd52228a8c643c102c7add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb4a9942b0dd52228a8c643c102c7add">&#9670;&#160;</a></span>paretovariate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const double <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::paretovariate </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pareto distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>double, the shape parameter. Cannot be 0.0.</td></tr>
  </table>
  </dd>
</dl>
<p>Important notice: the implemented code is a translation from Python <a href="https://github.com/python/cpython/blob/3.11/Lib/random.py">https://github.com/python/cpython/blob/3.11/Lib/random.py</a> into c++.</p>
<p>Pareto distribution. </p>

<p class="reference">References <a class="el" href="#gaca1fbb47b8f64989f590db78a46c3dc9">uniform()</a>.</p>

</div>
</div>
<a id="ga8e440e69c5e943e85f8fd778deebb92b" name="ga8e440e69c5e943e85f8fd778deebb92b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e440e69c5e943e85f8fd778deebb92b">&#9670;&#160;</a></span>randbytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::uint8_t &gt; <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::randbytes </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates n random bytes. </p>
<p>This method should not be used for generating security tokens.</p>
<p>Generates n random bytes. </p>

<p class="reference">References <a class="el" href="#gaca1fbb47b8f64989f590db78a46c3dc9">uniform()</a>.</p>

</div>
</div>
<a id="ga2c64096931dc07b192f92c131c2cb047" name="ga2c64096931dc07b192f92c131c2cb047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c64096931dc07b192f92c131c2cb047">&#9670;&#160;</a></span>randint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::randint </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns random integer in range [a, b], including both end points. </p>
<p>Template argument T must be an integral type.</p>
<p>Returns a random integer in range [a, b], including both end points. </p>

<p class="reference">References <a class="el" href="#gaca1fbb47b8f64989f590db78a46c3dc9">uniform()</a>.</p>

</div>
</div>
<a id="ga7dede5e1baced256563617889aef4b74" name="ga7dede5e1baced256563617889aef4b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7dede5e1baced256563617889aef4b74">&#9670;&#160;</a></span>randrange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<div class="memtemplate">
template&lt;typename T, typename S&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::randrange </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>stop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S</td>          <td class="paramname"><span class="paramname"><em>step</em></span><span class="paramdefsep"> = </span><span class="paramdefval">S(1)</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a random value in range [start, stop) with specified step. </p>
<p>Template arguments T and S must be arithmetic types.</p>
<p>Returns a random value in range [start, stop) with specified step. </p>

<p class="reference">References <a class="el" href="#gaca1fbb47b8f64989f590db78a46c3dc9">uniform()</a>.</p>

</div>
</div>
<a id="ga1f4df4281975073a3aac23184c87849b" name="ga1f4df4281975073a3aac23184c87849b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f4df4281975073a3aac23184c87849b">&#9670;&#160;</a></span>sample() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<div class="memtemplate">
template&lt;typename T, const std::size_t k, const std::size_t n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::sample </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, k &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, n &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>population</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chooses k unique random elements from a population sequence. All population elements have same weight for the sampling and are each chosen only once. </p>
<p>Evaluates a vector containing elements from the population while leaving the original population unchanged. The resulting list is in selection order so that all sub-slices will also be valid random samples. This allows raffle winners (the sample) to be partitioned into grand prize and second place winners (the subslices).</p>
<p>Members of the population need not be unique. If the population contains repeats, then each occurrence is a possible selection in the sample. Notice: k must be greater than n.</p>
<p>Chooses k unique random elements from a population sequence (out std::array&lt;&gt;, in std::array&lt;&gt;, default count per element = 1). </p>

<p class="reference">References <a class="el" href="#gaca1fbb47b8f64989f590db78a46c3dc9">uniform()</a>.</p>

</div>
</div>
<a id="gafc91ea302c18b4dfc1d01580c83d2a9e" name="gafc91ea302c18b4dfc1d01580c83d2a9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc91ea302c18b4dfc1d01580c83d2a9e">&#9670;&#160;</a></span>sample() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<div class="memtemplate">
template&lt;typename T, typename C, const std::size_t k, const std::size_t n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::sample </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, k &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, n &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>population</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; C, n &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>counts</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Chooses k unique random elements from a population sequence (std::array&lt;&gt;, with counts array). </p>
<p>Evaluates an array containing k elements from the population while leaving the original population unchanged. The resulting list is in selection order so that all sub-slices will also be valid random samples. This allows raffle winners (the sample) to be partitioned into grand prize and second place winners (the subslices).</p>
<p>Members of the population need not be unique. If the population contains repeats, then each occurrence is a possible selection in the sample.</p>
<p>Repeated elements are specified by the counts parameter. For example: std::array&lt;char*, 5&gt; out; sample(out, std::array&lt;char*, 2&gt;{"red", "blue"}, std::array&lt;int,2&gt;{4, 2}); is equivalent to: sample(out, std::array&lt;char*, 6&gt;{"red", "red", "red", "red", "blue", "blue"});</p>
<p>Chooses k unique random elements from a population sequence (std::array&lt;&gt;, with counts array). </p>

<p class="reference">References <a class="el" href="#gaca1fbb47b8f64989f590db78a46c3dc9">uniform()</a>.</p>

</div>
</div>
<a id="ga531781fa555945fc7afdcb1de65eaaa3" name="ga531781fa555945fc7afdcb1de65eaaa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga531781fa555945fc7afdcb1de65eaaa3">&#9670;&#160;</a></span>sample() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::sample </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>population</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>k</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chooses k unique random elements from a population sequence. All population elements have same weight for the sampling and are each chosen only once. </p>
<p>Evaluates a vector containing elements from the population while leaving the original population unchanged. The resulting list is in selection order so that all sub-slices will also be valid random samples. This allows raffle winners (the sample) to be partitioned into grand prize and second place winners (the subslices).</p>
<p>Members of the population need not be unique. If the population contains repeats, then each occurrence is a possible selection in the sample.</p>
<p>Chooses k unique random elements from a population sequence (out std::vector, in container, default count per element = 1). </p>

<p class="reference">References <a class="el" href="#gaca1fbb47b8f64989f590db78a46c3dc9">uniform()</a>.</p>

</div>
</div>
<a id="gac41f603988ac30aadcd9e805f924ad70" name="gac41f603988ac30aadcd9e805f924ad70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac41f603988ac30aadcd9e805f924ad70">&#9670;&#160;</a></span>sample() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<div class="memtemplate">
template&lt;typename T, typename C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::sample </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>population</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; C &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>counts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>k</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Chooses k unique random elements from a population sequence (std::vector&lt;&gt;, with counts vector). </p>
<p>Evaluates a vector containing elements from the population while leaving the original population unchanged. The resulting list is in selection order so that all sub-slices will also be valid random samples. This allows raffle winners (the sample) to be partitioned into grand prize and second place winners (the subslices).</p>
<p>Members of the population need not be unique. If the population contains repeats, then each occurrence is a possible selection in the selection in the sample.</p>
<p>Repeated elements are specified by the counts parameter. For example: sample({"red", "blue"}, {4, 2}, 5); is equivalent to: sample({"red", "red", "red", "red", "blue", "blue"}, 5);</p>
<p>Chooses k unique random elements from a population sequence (std::vector&lt;&gt;, with counts vector). </p>

<p class="reference">References <a class="el" href="#gaca1fbb47b8f64989f590db78a46c3dc9">uniform()</a>.</p>

</div>
</div>
<a id="ga80e9f597478c077279c5a126f791d032" name="ga80e9f597478c077279c5a126f791d032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80e9f597478c077279c5a126f791d032">&#9670;&#160;</a></span>seed() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::seed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes internal state (empty signature). </p>
<p>Uses an integer value evaluated from shuffled and xored current time as seed.</p>
<p>Initializes internal state (empty signature). </p>

<p>Reimplemented in <a class="el" href="group___c_w_g-algorithms.html#gaf0ab62de56bb08bf8e83e8a886633b00">BaseCWG&lt; ValueType, StateValueType, OutputType, OUTPUT_BITS &gt;</a>, <a class="el" href="group___c_w_g-algorithms.html#gaf0ab62de56bb08bf8e83e8a886633b00">BaseCWG&lt; std::uint64_t, std::uint64_t, std::uint64_t, 64 &gt;</a>, <a class="el" href="group___c_w_g-algorithms.html#gaf0ab62de56bb08bf8e83e8a886633b00">BaseCWG&lt; std::uint64_t, utils::UInt128, std::uint64_t, 64 &gt;</a>, <a class="el" href="group___c_w_g-algorithms.html#gaf0ab62de56bb08bf8e83e8a886633b00">BaseCWG&lt; utils::UInt128, utils::UInt128, utils::UInt128, 128 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga147f3f33109e62963fa242b8ea46dc70">BaseLFib64&lt; SIZE, K &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga147f3f33109e62963fa242b8ea46dc70">BaseLFib64&lt; 1279, 861 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga147f3f33109e62963fa242b8ea46dc70">BaseLFib64&lt; 17, 5 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga147f3f33109e62963fa242b8ea46dc70">BaseLFib64&lt; 55, 24 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga147f3f33109e62963fa242b8ea46dc70">BaseLFib64&lt; 607, 273 &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#gac94b3adb2deff2684c95dd29b9690bcf">BaseMELG&lt; SIZE &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#gac94b3adb2deff2684c95dd29b9690bcf">BaseMELG&lt; 10 &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#gac94b3adb2deff2684c95dd29b9690bcf">BaseMELG&lt; 312 &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#gac94b3adb2deff2684c95dd29b9690bcf">BaseMELG&lt; 696 &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#gabe45b8beede690e9dfde1c5c701d9125">BaseMRG31&lt; SIZE &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#gabe45b8beede690e9dfde1c5c701d9125">BaseMRG31&lt; 1597 &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#gabe45b8beede690e9dfde1c5c701d9125">BaseMRG31&lt; 47 &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#gaf45ea752c810b2667ad245a9570c0c7a">BaseMRG32&lt; SIZE &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#gaf45ea752c810b2667ad245a9570c0c7a">BaseMRG32&lt; 256 &gt;</a>, <a class="el" href="group___squares-algorithms.html#ga019ca329537ce2f6d08153095b78988a">BaseSquares&lt; OutputT &gt;</a>, <a class="el" href="group___squares-algorithms.html#ga019ca329537ce2f6d08153095b78988a">BaseSquares&lt; std::uint32_t &gt;</a>, <a class="el" href="group___squares-algorithms.html#ga019ca329537ce2f6d08153095b78988a">BaseSquares&lt; std::uint64_t &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#ga29097d11f36880d9e312ea7591d0ef3e">BaseWell&lt; SIZE &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#ga29097d11f36880d9e312ea7591d0ef3e">BaseWell&lt; 1391 &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#ga29097d11f36880d9e312ea7591d0ef3e">BaseWell&lt; 16 &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#ga29097d11f36880d9e312ea7591d0ef3e">BaseWell&lt; 32 &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#ga29097d11f36880d9e312ea7591d0ef3e">BaseWell&lt; 624 &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#gafac318ad57a8a083f06fc7fc9f7570f5">BaseXoroshiro&lt; SIZE &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#gafac318ad57a8a083f06fc7fc9f7570f5">BaseXoroshiro&lt; 16 &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#gafac318ad57a8a083f06fc7fc9f7570f5">BaseXoroshiro&lt; 4 &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#gafac318ad57a8a083f06fc7fc9f7570f5">BaseXoroshiro&lt; 8 &gt;</a>, <a class="el" href="class_cwg128.html#ab805f5413b8b3d17a351068994001a17">Cwg128</a>, <a class="el" href="class_cwg128__64.html#a1231a135515a5366858f41b9488ca1bb">Cwg128_64</a>, <a class="el" href="class_cwg64.html#ab370ece836868e364c0112556f29cac1">Cwg64</a>, <a class="el" href="group___l_c_g-algorithms.html#gacaa22b9094f30df565a0ea42b31a295a">FastRand32</a>, <a class="el" href="group___l_c_g-algorithms.html#gaf6b5b93789fead7de166e91e30755d1c">FastRand63</a>, <a class="el" href="class_melg19937.html#a5ac3f5aa21254fbc90d28a445e2cc1b4">Melg19937</a>, <a class="el" href="class_melg44497.html#a60e1d513a9b82ef774a6221ccc9d958d">Melg44497</a>, <a class="el" href="class_melg607.html#a4bfa36bc4f5fc0071667b9ca1cdfad8f">Melg607</a>, <a class="el" href="class_pcg1024__32.html#ac87ed386e7fc788e8a0f4fa750d72657">Pcg1024_32</a>, <a class="el" href="class_pcg128__64.html#a1986b5bb0a61e0be0c20d2a328027b31">Pcg128_64</a>, and <a class="el" href="class_pcg64__32.html#a0bb83e7597bd7f578919d71e6d5ce806">Pcg64_32</a>.</p>

<p class="reference">References <a class="el" href="#ga80e9f597478c077279c5a126f791d032">seed()</a>, and <a class="el" href="group__seed__generation.html#ga7a66acce4e57252c5dea6da90833b6ac">utils::set_random_seed64()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#ga80e9f597478c077279c5a126f791d032">seed()</a>, <a class="el" href="#ga83c4d1f15cba8c9d5ba92d1234a1ba11">seed()</a>, <a class="el" href="#ga90bad605714495ec531ffe3f2d57c3b5">seed()</a>, <a class="el" href="#ga2d3343e9f37a406a1338103d88b7ec24">seed()</a>, <a class="el" href="#gacb33118938b2f5036bcd48161f36fb34">seed()</a>, and <a class="el" href="#ga2b3ad383892f59932e792ced6fe9626b">seed()</a>.</p>

</div>
</div>
<a id="ga83c4d1f15cba8c9d5ba92d1234a1ba11" name="ga83c4d1f15cba8c9d5ba92d1234a1ba11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83c4d1f15cba8c9d5ba92d1234a1ba11">&#9670;&#160;</a></span>seed() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::seed </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>seed_</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initalizes internal state from a double seed. </p>
<p>Initalizes internal state from a double seed. </p>

<p>Reimplemented in <a class="el" href="group___c_w_g-algorithms.html#ga6891cb2e1275ab8e421b2edeb92a01d3">BaseCWG&lt; ValueType, StateValueType, OutputType, OUTPUT_BITS &gt;</a>, <a class="el" href="group___c_w_g-algorithms.html#ga6891cb2e1275ab8e421b2edeb92a01d3">BaseCWG&lt; std::uint64_t, std::uint64_t, std::uint64_t, 64 &gt;</a>, <a class="el" href="group___c_w_g-algorithms.html#ga6891cb2e1275ab8e421b2edeb92a01d3">BaseCWG&lt; std::uint64_t, utils::UInt128, std::uint64_t, 64 &gt;</a>, <a class="el" href="group___c_w_g-algorithms.html#ga6891cb2e1275ab8e421b2edeb92a01d3">BaseCWG&lt; utils::UInt128, utils::UInt128, utils::UInt128, 128 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga56e3a20443f3fcb35dd5f2762b579c4b">BaseLFib64&lt; SIZE, K &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga56e3a20443f3fcb35dd5f2762b579c4b">BaseLFib64&lt; 1279, 861 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga56e3a20443f3fcb35dd5f2762b579c4b">BaseLFib64&lt; 17, 5 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga56e3a20443f3fcb35dd5f2762b579c4b">BaseLFib64&lt; 55, 24 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga56e3a20443f3fcb35dd5f2762b579c4b">BaseLFib64&lt; 607, 273 &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#gaa10e66bd86dde2d8eb29c912727618ab">BaseMELG&lt; SIZE &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#gaa10e66bd86dde2d8eb29c912727618ab">BaseMELG&lt; 10 &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#gaa10e66bd86dde2d8eb29c912727618ab">BaseMELG&lt; 312 &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#gaa10e66bd86dde2d8eb29c912727618ab">BaseMELG&lt; 696 &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#ga98b4a1e0c47d18c1d9f48fc493bbf911">BaseMRG31&lt; SIZE &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#ga98b4a1e0c47d18c1d9f48fc493bbf911">BaseMRG31&lt; 1597 &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#ga98b4a1e0c47d18c1d9f48fc493bbf911">BaseMRG31&lt; 47 &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#ga4272ac4d082aa699db4fa89a95b6db0d">BaseMRG32&lt; SIZE &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#ga4272ac4d082aa699db4fa89a95b6db0d">BaseMRG32&lt; 256 &gt;</a>, <a class="el" href="group___squares-algorithms.html#ga4fa2888731f45e477557fa18e66d0219">BaseSquares&lt; OutputT &gt;</a>, <a class="el" href="group___squares-algorithms.html#ga4fa2888731f45e477557fa18e66d0219">BaseSquares&lt; std::uint32_t &gt;</a>, <a class="el" href="group___squares-algorithms.html#ga4fa2888731f45e477557fa18e66d0219">BaseSquares&lt; std::uint64_t &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#ga7a7e254ee749e6f1155444a23cf16770">BaseWell&lt; SIZE &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#ga7a7e254ee749e6f1155444a23cf16770">BaseWell&lt; 1391 &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#ga7a7e254ee749e6f1155444a23cf16770">BaseWell&lt; 16 &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#ga7a7e254ee749e6f1155444a23cf16770">BaseWell&lt; 32 &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#ga7a7e254ee749e6f1155444a23cf16770">BaseWell&lt; 624 &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#ga4aeb934fd6b2029c948233bd53c845b1">BaseXoroshiro&lt; SIZE &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#ga4aeb934fd6b2029c948233bd53c845b1">BaseXoroshiro&lt; 16 &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#ga4aeb934fd6b2029c948233bd53c845b1">BaseXoroshiro&lt; 4 &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#ga4aeb934fd6b2029c948233bd53c845b1">BaseXoroshiro&lt; 8 &gt;</a>, <a class="el" href="class_cwg128.html#a87adeb754a3368e99b54d8f74b92dc2d">Cwg128</a>, <a class="el" href="class_cwg128__64.html#acb38e212737b3ef0fc8ae7a1a3a6662f">Cwg128_64</a>, <a class="el" href="class_cwg64.html#a3acc5674516b46f495c721913a98a80d">Cwg64</a>, <a class="el" href="group___l_c_g-algorithms.html#gad144ecdc96066d04bf767e11e08e6e92">FastRand32</a>, <a class="el" href="group___l_c_g-algorithms.html#gacd6d817d21ee4ca90afd488740843d2c">FastRand63</a>, <a class="el" href="class_melg19937.html#aca837299eff7029c60fa907623429b05">Melg19937</a>, <a class="el" href="class_melg44497.html#abb05d662d0df2ee79df316e80aad3fe2">Melg44497</a>, <a class="el" href="class_melg607.html#af9b130abcc5d14a1b98ef085d838f7e8">Melg607</a>, <a class="el" href="class_pcg1024__32.html#abaf14398b9f51e02da7ecab667f15fcf">Pcg1024_32</a>, <a class="el" href="class_pcg128__64.html#aee0df6e568bf31e24c0264d23cbf5d7b">Pcg128_64</a>, and <a class="el" href="class_pcg64__32.html#a2a4a0e358a92e1c675373572f798d6bd">Pcg64_32</a>.</p>

<p class="reference">References <a class="el" href="#ga80e9f597478c077279c5a126f791d032">seed()</a>.</p>

</div>
</div>
<a id="ga90bad605714495ec531ffe3f2d57c3b5" name="ga90bad605714495ec531ffe3f2d57c3b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90bad605714495ec531ffe3f2d57c3b5">&#9670;&#160;</a></span>seed() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::seed </td>
          <td>(</td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>seed_</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes internal state from a 32-bits signed integer seed. </p>
<p>Initializes internal state from a 32-bits signed integer seed. </p>

<p>Reimplemented in <a class="el" href="group___c_w_g-algorithms.html#ga164a8038585cf253f24f6c33565db1ff">BaseCWG&lt; ValueType, StateValueType, OutputType, OUTPUT_BITS &gt;</a>, <a class="el" href="group___c_w_g-algorithms.html#ga164a8038585cf253f24f6c33565db1ff">BaseCWG&lt; std::uint64_t, std::uint64_t, std::uint64_t, 64 &gt;</a>, <a class="el" href="group___c_w_g-algorithms.html#ga164a8038585cf253f24f6c33565db1ff">BaseCWG&lt; std::uint64_t, utils::UInt128, std::uint64_t, 64 &gt;</a>, <a class="el" href="group___c_w_g-algorithms.html#ga164a8038585cf253f24f6c33565db1ff">BaseCWG&lt; utils::UInt128, utils::UInt128, utils::UInt128, 128 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga6381bf6cd2530da6ea6b9f19c2ee47b0">BaseLFib64&lt; SIZE, K &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga6381bf6cd2530da6ea6b9f19c2ee47b0">BaseLFib64&lt; 1279, 861 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga6381bf6cd2530da6ea6b9f19c2ee47b0">BaseLFib64&lt; 17, 5 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga6381bf6cd2530da6ea6b9f19c2ee47b0">BaseLFib64&lt; 55, 24 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga6381bf6cd2530da6ea6b9f19c2ee47b0">BaseLFib64&lt; 607, 273 &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#ga5e0284ce658345818ae344fb03ea027f">BaseMELG&lt; SIZE &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#ga5e0284ce658345818ae344fb03ea027f">BaseMELG&lt; 10 &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#ga5e0284ce658345818ae344fb03ea027f">BaseMELG&lt; 312 &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#ga5e0284ce658345818ae344fb03ea027f">BaseMELG&lt; 696 &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#ga55a59b49f7bb97e4b70f043ccb9b953c">BaseMRG31&lt; SIZE &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#ga55a59b49f7bb97e4b70f043ccb9b953c">BaseMRG31&lt; 1597 &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#ga55a59b49f7bb97e4b70f043ccb9b953c">BaseMRG31&lt; 47 &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#ga375d1ec99b9be8e34d9992d0e51057ee">BaseMRG32&lt; SIZE &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#ga375d1ec99b9be8e34d9992d0e51057ee">BaseMRG32&lt; 256 &gt;</a>, <a class="el" href="group___squares-algorithms.html#gae7e93bf9e1c5bb21d1cb679bc9d8f0b7">BaseSquares&lt; OutputT &gt;</a>, <a class="el" href="group___squares-algorithms.html#gae7e93bf9e1c5bb21d1cb679bc9d8f0b7">BaseSquares&lt; std::uint32_t &gt;</a>, <a class="el" href="group___squares-algorithms.html#gae7e93bf9e1c5bb21d1cb679bc9d8f0b7">BaseSquares&lt; std::uint64_t &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#gae1c2d7127b7bef097a49db22283c6ba7">BaseWell&lt; SIZE &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#gae1c2d7127b7bef097a49db22283c6ba7">BaseWell&lt; 1391 &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#gae1c2d7127b7bef097a49db22283c6ba7">BaseWell&lt; 16 &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#gae1c2d7127b7bef097a49db22283c6ba7">BaseWell&lt; 32 &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#gae1c2d7127b7bef097a49db22283c6ba7">BaseWell&lt; 624 &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#gad3611602f1456b05cf431587860e6f0b">BaseXoroshiro&lt; SIZE &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#gad3611602f1456b05cf431587860e6f0b">BaseXoroshiro&lt; 16 &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#gad3611602f1456b05cf431587860e6f0b">BaseXoroshiro&lt; 4 &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#gad3611602f1456b05cf431587860e6f0b">BaseXoroshiro&lt; 8 &gt;</a>, <a class="el" href="class_cwg128.html#a4f6bf8976592b21f0bb18b71efd2867c">Cwg128</a>, <a class="el" href="class_cwg128__64.html#a4cc07912c2e8230c7449da28c8796c2a">Cwg128_64</a>, <a class="el" href="class_cwg64.html#a77f7a69fc2c8faefab6a11885c8ead8f">Cwg64</a>, <a class="el" href="group___l_c_g-algorithms.html#gae90c6247485d75f7c952878876181ff9">FastRand32</a>, <a class="el" href="group___l_c_g-algorithms.html#ga20a8ea55cfe2baa38b486b998331ff44">FastRand63</a>, <a class="el" href="class_melg19937.html#a3b0fbd70ad74bdc9d35c01164bc84ba4">Melg19937</a>, <a class="el" href="class_melg44497.html#a046b61fcf6040587fa5ed404e65f6547">Melg44497</a>, <a class="el" href="class_melg607.html#a4955b9cfe5d365d25866979d3d100a58">Melg607</a>, <a class="el" href="class_pcg1024__32.html#aa50e5df3cb7cd76eca3a2117d6f39b6f">Pcg1024_32</a>, <a class="el" href="class_pcg128__64.html#a51bfe49bd4142a338ac34c2b7f58e766">Pcg128_64</a>, and <a class="el" href="class_pcg64__32.html#a163d4d07028e566363068df2f80961b6">Pcg64_32</a>.</p>

<p class="reference">References <a class="el" href="#ga80e9f597478c077279c5a126f791d032">seed()</a>.</p>

</div>
</div>
<a id="ga2d3343e9f37a406a1338103d88b7ec24" name="ga2d3343e9f37a406a1338103d88b7ec24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d3343e9f37a406a1338103d88b7ec24">&#9670;&#160;</a></span>seed() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::seed </td>
          <td>(</td>
          <td class="paramtype">const long long</td>          <td class="paramname"><span class="paramname"><em>seed_</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes internal state from a 64-bits signed integer seed. </p>
<p>Initializes internal state from a 64-bits signed integer seed. </p>

<p>Reimplemented in <a class="el" href="group___c_w_g-algorithms.html#gafce80b0081d925c9fcb1808757b35053">BaseCWG&lt; ValueType, StateValueType, OutputType, OUTPUT_BITS &gt;</a>, <a class="el" href="group___c_w_g-algorithms.html#gafce80b0081d925c9fcb1808757b35053">BaseCWG&lt; std::uint64_t, std::uint64_t, std::uint64_t, 64 &gt;</a>, <a class="el" href="group___c_w_g-algorithms.html#gafce80b0081d925c9fcb1808757b35053">BaseCWG&lt; std::uint64_t, utils::UInt128, std::uint64_t, 64 &gt;</a>, <a class="el" href="group___c_w_g-algorithms.html#gafce80b0081d925c9fcb1808757b35053">BaseCWG&lt; utils::UInt128, utils::UInt128, utils::UInt128, 128 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga83b3195800083ff6748d2e486b19b1d7">BaseLFib64&lt; SIZE, K &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga83b3195800083ff6748d2e486b19b1d7">BaseLFib64&lt; 1279, 861 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga83b3195800083ff6748d2e486b19b1d7">BaseLFib64&lt; 17, 5 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga83b3195800083ff6748d2e486b19b1d7">BaseLFib64&lt; 55, 24 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga83b3195800083ff6748d2e486b19b1d7">BaseLFib64&lt; 607, 273 &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#ga87700d1188f87f23b8567852e1e85313">BaseMELG&lt; SIZE &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#ga87700d1188f87f23b8567852e1e85313">BaseMELG&lt; 10 &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#ga87700d1188f87f23b8567852e1e85313">BaseMELG&lt; 312 &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#ga87700d1188f87f23b8567852e1e85313">BaseMELG&lt; 696 &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#ga6c7ede60a2b452fabe914f23a50ea565">BaseMRG31&lt; SIZE &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#ga6c7ede60a2b452fabe914f23a50ea565">BaseMRG31&lt; 1597 &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#ga6c7ede60a2b452fabe914f23a50ea565">BaseMRG31&lt; 47 &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#gaf5fe858401311ca6bc0a6e5c4359c8dc">BaseMRG32&lt; SIZE &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#gaf5fe858401311ca6bc0a6e5c4359c8dc">BaseMRG32&lt; 256 &gt;</a>, <a class="el" href="group___squares-algorithms.html#ga0f6df56a45146bb703ce48c867777690">BaseSquares&lt; OutputT &gt;</a>, <a class="el" href="group___squares-algorithms.html#ga0f6df56a45146bb703ce48c867777690">BaseSquares&lt; std::uint32_t &gt;</a>, <a class="el" href="group___squares-algorithms.html#ga0f6df56a45146bb703ce48c867777690">BaseSquares&lt; std::uint64_t &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#ga6aeb044dcfbc48e97cc55c967430e78a">BaseWell&lt; SIZE &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#ga6aeb044dcfbc48e97cc55c967430e78a">BaseWell&lt; 1391 &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#ga6aeb044dcfbc48e97cc55c967430e78a">BaseWell&lt; 16 &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#ga6aeb044dcfbc48e97cc55c967430e78a">BaseWell&lt; 32 &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#ga6aeb044dcfbc48e97cc55c967430e78a">BaseWell&lt; 624 &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#ga92c59d08c38aa65dc437165f5e28d53b">BaseXoroshiro&lt; SIZE &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#ga92c59d08c38aa65dc437165f5e28d53b">BaseXoroshiro&lt; 16 &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#ga92c59d08c38aa65dc437165f5e28d53b">BaseXoroshiro&lt; 4 &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#ga92c59d08c38aa65dc437165f5e28d53b">BaseXoroshiro&lt; 8 &gt;</a>, <a class="el" href="class_cwg128.html#af3f3a0eba5b2c96f3f2758cd061bf01d">Cwg128</a>, <a class="el" href="class_cwg128__64.html#a7b202068be681b62f3035035987c6fff">Cwg128_64</a>, <a class="el" href="class_cwg64.html#a4646147fd171558a68346d76140be744">Cwg64</a>, <a class="el" href="group___l_c_g-algorithms.html#ga12f8dc0a4e48292ead1c1285e72a404b">FastRand32</a>, <a class="el" href="group___l_c_g-algorithms.html#gaf986612fd677903ad805f87ce23f1585">FastRand63</a>, <a class="el" href="class_melg19937.html#a05fec72b0bab4e888d39ea5f52d87513">Melg19937</a>, <a class="el" href="class_melg44497.html#a04a025613531aeddb30401ac9e11c228">Melg44497</a>, <a class="el" href="class_melg607.html#a8326be421e87523e0340fb57d30aacb7">Melg607</a>, <a class="el" href="class_pcg1024__32.html#a9350e3de7a985f5802806617cfd60839">Pcg1024_32</a>, <a class="el" href="class_pcg128__64.html#a687d658e6bef0795531de0906c60366c">Pcg128_64</a>, and <a class="el" href="class_pcg64__32.html#a8a8db1275f8a8e3fe01e572272e91f08">Pcg64_32</a>.</p>

<p class="reference">References <a class="el" href="#ga80e9f597478c077279c5a126f791d032">seed()</a>.</p>

</div>
</div>
<a id="gacb33118938b2f5036bcd48161f36fb34" name="gacb33118938b2f5036bcd48161f36fb34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb33118938b2f5036bcd48161f36fb34">&#9670;&#160;</a></span>seed() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::seed </td>
          <td>(</td>
          <td class="paramtype">const long</td>          <td class="paramname"><span class="paramname"><em>seed_</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes internal state from a 32-bits signed integer seed. </p>
<p>Initializes internal state from a 32-bits signed integer seed. </p>

<p>Reimplemented in <a class="el" href="group___c_w_g-algorithms.html#gaef6d4274e3bc75a1ae3ccbb398778afc">BaseCWG&lt; ValueType, StateValueType, OutputType, OUTPUT_BITS &gt;</a>, <a class="el" href="group___c_w_g-algorithms.html#gaef6d4274e3bc75a1ae3ccbb398778afc">BaseCWG&lt; std::uint64_t, std::uint64_t, std::uint64_t, 64 &gt;</a>, <a class="el" href="group___c_w_g-algorithms.html#gaef6d4274e3bc75a1ae3ccbb398778afc">BaseCWG&lt; std::uint64_t, utils::UInt128, std::uint64_t, 64 &gt;</a>, <a class="el" href="group___c_w_g-algorithms.html#gaef6d4274e3bc75a1ae3ccbb398778afc">BaseCWG&lt; utils::UInt128, utils::UInt128, utils::UInt128, 128 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga80834b09e769ad16ff147326fc3e349b">BaseLFib64&lt; SIZE, K &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga80834b09e769ad16ff147326fc3e349b">BaseLFib64&lt; 1279, 861 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga80834b09e769ad16ff147326fc3e349b">BaseLFib64&lt; 17, 5 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga80834b09e769ad16ff147326fc3e349b">BaseLFib64&lt; 55, 24 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga80834b09e769ad16ff147326fc3e349b">BaseLFib64&lt; 607, 273 &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#ga16c1f4fdf64de8a9846f43d1bb57687c">BaseMELG&lt; SIZE &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#ga16c1f4fdf64de8a9846f43d1bb57687c">BaseMELG&lt; 10 &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#ga16c1f4fdf64de8a9846f43d1bb57687c">BaseMELG&lt; 312 &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#ga16c1f4fdf64de8a9846f43d1bb57687c">BaseMELG&lt; 696 &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#ga9283dabc264eaf9ee757979ec3f6beb8">BaseMRG31&lt; SIZE &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#ga9283dabc264eaf9ee757979ec3f6beb8">BaseMRG31&lt; 1597 &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#ga9283dabc264eaf9ee757979ec3f6beb8">BaseMRG31&lt; 47 &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#ga426ae7523e8f5ba2b2d8c12738aace28">BaseMRG32&lt; SIZE &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#ga426ae7523e8f5ba2b2d8c12738aace28">BaseMRG32&lt; 256 &gt;</a>, <a class="el" href="group___squares-algorithms.html#ga2942717a66c9bc3529f4f32c2300559e">BaseSquares&lt; OutputT &gt;</a>, <a class="el" href="group___squares-algorithms.html#ga2942717a66c9bc3529f4f32c2300559e">BaseSquares&lt; std::uint32_t &gt;</a>, <a class="el" href="group___squares-algorithms.html#ga2942717a66c9bc3529f4f32c2300559e">BaseSquares&lt; std::uint64_t &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#ga0830f2634aa4f3e5580a0ff51061590c">BaseWell&lt; SIZE &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#ga0830f2634aa4f3e5580a0ff51061590c">BaseWell&lt; 1391 &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#ga0830f2634aa4f3e5580a0ff51061590c">BaseWell&lt; 16 &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#ga0830f2634aa4f3e5580a0ff51061590c">BaseWell&lt; 32 &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#ga0830f2634aa4f3e5580a0ff51061590c">BaseWell&lt; 624 &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#ga5a376a60707e6340e66c30d07b48ff1f">BaseXoroshiro&lt; SIZE &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#ga5a376a60707e6340e66c30d07b48ff1f">BaseXoroshiro&lt; 16 &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#ga5a376a60707e6340e66c30d07b48ff1f">BaseXoroshiro&lt; 4 &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#ga5a376a60707e6340e66c30d07b48ff1f">BaseXoroshiro&lt; 8 &gt;</a>, <a class="el" href="class_cwg128.html#ab1ce2cb9cdc97494b1b0cadf51f34201">Cwg128</a>, <a class="el" href="class_cwg128__64.html#a3487a204a55f9514be1471240a7fff05">Cwg128_64</a>, <a class="el" href="class_cwg64.html#a02c6443fbdcfd75f4fdacb8109df7f62">Cwg64</a>, <a class="el" href="group___l_c_g-algorithms.html#ga78e36e6c837602b32a638bf8a47ab862">FastRand32</a>, <a class="el" href="group___l_c_g-algorithms.html#gad8a9b12383f489de0db48b9f103143af">FastRand63</a>, <a class="el" href="class_melg19937.html#a99e1380615a0cb19292c22c54eb2c365">Melg19937</a>, <a class="el" href="class_melg44497.html#abe37d9fc137ce62befb1208ecdd6f76d">Melg44497</a>, <a class="el" href="class_melg607.html#a8e6273b36953b709f394c88bb95792ff">Melg607</a>, <a class="el" href="class_pcg1024__32.html#a39548b3a5cd15ffa7de47373a4c9bd56">Pcg1024_32</a>, <a class="el" href="class_pcg128__64.html#a3ccad18b363550d79f0d0fdcfd7cc057">Pcg128_64</a>, and <a class="el" href="class_pcg64__32.html#aa4a8c61ab02585d871df268168e253ac">Pcg64_32</a>.</p>

<p class="reference">References <a class="el" href="#ga80e9f597478c077279c5a126f791d032">seed()</a>.</p>

</div>
</div>
<a id="ga2b3ad383892f59932e792ced6fe9626b" name="ga2b3ad383892f59932e792ced6fe9626b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b3ad383892f59932e792ced6fe9626b">&#9670;&#160;</a></span>seed() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::seed </td>
          <td>(</td>
          <td class="paramtype">const unsigned int</td>          <td class="paramname"><span class="paramname"><em>seed_</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes internal state from a 32-bits unsigned integer seed. </p>
<p>Initializes internal state from a 32-bits unsigned integer seed. </p>

<p>Reimplemented in <a class="el" href="group___c_w_g-algorithms.html#gaa33b68e28704d4cea586a19f744bbe92">BaseCWG&lt; ValueType, StateValueType, OutputType, OUTPUT_BITS &gt;</a>, <a class="el" href="group___c_w_g-algorithms.html#gaa33b68e28704d4cea586a19f744bbe92">BaseCWG&lt; std::uint64_t, std::uint64_t, std::uint64_t, 64 &gt;</a>, <a class="el" href="group___c_w_g-algorithms.html#gaa33b68e28704d4cea586a19f744bbe92">BaseCWG&lt; std::uint64_t, utils::UInt128, std::uint64_t, 64 &gt;</a>, <a class="el" href="group___c_w_g-algorithms.html#gaa33b68e28704d4cea586a19f744bbe92">BaseCWG&lt; utils::UInt128, utils::UInt128, utils::UInt128, 128 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga7c1e1e93374c76cf787daca8429f41af">BaseLFib64&lt; SIZE, K &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga7c1e1e93374c76cf787daca8429f41af">BaseLFib64&lt; 1279, 861 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga7c1e1e93374c76cf787daca8429f41af">BaseLFib64&lt; 17, 5 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga7c1e1e93374c76cf787daca8429f41af">BaseLFib64&lt; 55, 24 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga7c1e1e93374c76cf787daca8429f41af">BaseLFib64&lt; 607, 273 &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#gaaddcfbd759e3ad3870032baaa9d32c5e">BaseMELG&lt; SIZE &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#gaaddcfbd759e3ad3870032baaa9d32c5e">BaseMELG&lt; 10 &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#gaaddcfbd759e3ad3870032baaa9d32c5e">BaseMELG&lt; 312 &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#gaaddcfbd759e3ad3870032baaa9d32c5e">BaseMELG&lt; 696 &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#ga9d3429c0539901abab2fa28e253447b5">BaseMRG31&lt; SIZE &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#ga9d3429c0539901abab2fa28e253447b5">BaseMRG31&lt; 1597 &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#ga9d3429c0539901abab2fa28e253447b5">BaseMRG31&lt; 47 &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#ga6749ee56033a1b1d5489e3df3ceb4247">BaseMRG32&lt; SIZE &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#ga6749ee56033a1b1d5489e3df3ceb4247">BaseMRG32&lt; 256 &gt;</a>, <a class="el" href="group___squares-algorithms.html#ga5fb1d5afb65727d6cb0216e45c81fc77">BaseSquares&lt; OutputT &gt;</a>, <a class="el" href="group___squares-algorithms.html#ga5fb1d5afb65727d6cb0216e45c81fc77">BaseSquares&lt; std::uint32_t &gt;</a>, <a class="el" href="group___squares-algorithms.html#ga5fb1d5afb65727d6cb0216e45c81fc77">BaseSquares&lt; std::uint64_t &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#ga668a089d0abc678cd03e956275a2e25c">BaseWell&lt; SIZE &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#ga668a089d0abc678cd03e956275a2e25c">BaseWell&lt; 1391 &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#ga668a089d0abc678cd03e956275a2e25c">BaseWell&lt; 16 &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#ga668a089d0abc678cd03e956275a2e25c">BaseWell&lt; 32 &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#ga668a089d0abc678cd03e956275a2e25c">BaseWell&lt; 624 &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#ga2dc169d0ebdcbe276a63b2d61d60645f">BaseXoroshiro&lt; SIZE &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#ga2dc169d0ebdcbe276a63b2d61d60645f">BaseXoroshiro&lt; 16 &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#ga2dc169d0ebdcbe276a63b2d61d60645f">BaseXoroshiro&lt; 4 &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#ga2dc169d0ebdcbe276a63b2d61d60645f">BaseXoroshiro&lt; 8 &gt;</a>, <a class="el" href="class_cwg128.html#a8dad3190e241f2114a067797081bdbd8">Cwg128</a>, <a class="el" href="class_cwg128__64.html#a64d3e71afcc3aca29732eedce60c2495">Cwg128_64</a>, <a class="el" href="class_cwg64.html#a40d867ebac278bc05b91d4414831b2eb">Cwg64</a>, <a class="el" href="group___l_c_g-algorithms.html#ga60b50d0c46210c77902fd70b38eac05c">FastRand32</a>, <a class="el" href="group___l_c_g-algorithms.html#gadea0a34d3a59ab8f0f0198d47caa0f30">FastRand63</a>, <a class="el" href="class_melg19937.html#a37e77df2d07f171f1a8f32ce8ab64ee1">Melg19937</a>, <a class="el" href="class_melg44497.html#aa3e587a85e1b18228620d4a3b7603707">Melg44497</a>, <a class="el" href="class_melg607.html#a9ca137d0e0cf39a3c6094e6dccef5aaa">Melg607</a>, <a class="el" href="class_pcg1024__32.html#aa29972d2ee7228cbfebff3ae5be183f1">Pcg1024_32</a>, <a class="el" href="class_pcg128__64.html#adaa307cbc8db609d495692a997675ac2">Pcg128_64</a>, and <a class="el" href="class_pcg64__32.html#ac9a45afa24117dfecb18e276cf417f37">Pcg64_32</a>.</p>

<p class="reference">References <a class="el" href="#ga80e9f597478c077279c5a126f791d032">seed()</a>.</p>

</div>
</div>
<a id="ga9e930fe3a6d8f5db9ebaf0b31af41a91" name="ga9e930fe3a6d8f5db9ebaf0b31af41a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e930fe3a6d8f5db9ebaf0b31af41a91">&#9670;&#160;</a></span>seed() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::seed </td>
          <td>(</td>
          <td class="paramtype">const unsigned long long</td>          <td class="paramname"><span class="paramname"><em>seed_</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes internal state from a 64-bits unsigned integer seed. </p>
<p>Initializes internal state from a 64-bits unsigned integer seed. </p>

<p>Reimplemented in <a class="el" href="group___c_w_g-algorithms.html#ga272f47f43cb3ef0bb4e7a7cddd5e5206">BaseCWG&lt; ValueType, StateValueType, OutputType, OUTPUT_BITS &gt;</a>, <a class="el" href="group___c_w_g-algorithms.html#ga272f47f43cb3ef0bb4e7a7cddd5e5206">BaseCWG&lt; std::uint64_t, std::uint64_t, std::uint64_t, 64 &gt;</a>, <a class="el" href="group___c_w_g-algorithms.html#ga272f47f43cb3ef0bb4e7a7cddd5e5206">BaseCWG&lt; std::uint64_t, utils::UInt128, std::uint64_t, 64 &gt;</a>, <a class="el" href="group___c_w_g-algorithms.html#ga272f47f43cb3ef0bb4e7a7cddd5e5206">BaseCWG&lt; utils::UInt128, utils::UInt128, utils::UInt128, 128 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#gac83d748b0f9651c4c4669cb07b6e18dc">BaseLFib64&lt; SIZE, K &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#gac83d748b0f9651c4c4669cb07b6e18dc">BaseLFib64&lt; 1279, 861 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#gac83d748b0f9651c4c4669cb07b6e18dc">BaseLFib64&lt; 17, 5 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#gac83d748b0f9651c4c4669cb07b6e18dc">BaseLFib64&lt; 55, 24 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#gac83d748b0f9651c4c4669cb07b6e18dc">BaseLFib64&lt; 607, 273 &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#ga18297b9101f7dcd77b5b7de403a696d0">BaseMELG&lt; SIZE &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#ga18297b9101f7dcd77b5b7de403a696d0">BaseMELG&lt; 10 &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#ga18297b9101f7dcd77b5b7de403a696d0">BaseMELG&lt; 312 &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#ga18297b9101f7dcd77b5b7de403a696d0">BaseMELG&lt; 696 &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#gaefd693fd2b4cf767d393b2153cf9f51b">BaseMRG31&lt; SIZE &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#gaefd693fd2b4cf767d393b2153cf9f51b">BaseMRG31&lt; 1597 &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#gaefd693fd2b4cf767d393b2153cf9f51b">BaseMRG31&lt; 47 &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#gad7da5c10a349f3aac4da9ee29eb57567">BaseMRG32&lt; SIZE &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#gad7da5c10a349f3aac4da9ee29eb57567">BaseMRG32&lt; 256 &gt;</a>, <a class="el" href="group___squares-algorithms.html#ga1425bb83eb89e8294ed7c608883df8d4">BaseSquares&lt; OutputT &gt;</a>, <a class="el" href="group___squares-algorithms.html#ga1425bb83eb89e8294ed7c608883df8d4">BaseSquares&lt; std::uint32_t &gt;</a>, <a class="el" href="group___squares-algorithms.html#ga1425bb83eb89e8294ed7c608883df8d4">BaseSquares&lt; std::uint64_t &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#ga5d5cee59d0fc011148837a147811f254">BaseWell&lt; SIZE &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#ga5d5cee59d0fc011148837a147811f254">BaseWell&lt; 1391 &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#ga5d5cee59d0fc011148837a147811f254">BaseWell&lt; 16 &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#ga5d5cee59d0fc011148837a147811f254">BaseWell&lt; 32 &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#ga5d5cee59d0fc011148837a147811f254">BaseWell&lt; 624 &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#ga0bba3bbcd12e3f28d2980995107d27ab">BaseXoroshiro&lt; SIZE &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#ga0bba3bbcd12e3f28d2980995107d27ab">BaseXoroshiro&lt; 16 &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#ga0bba3bbcd12e3f28d2980995107d27ab">BaseXoroshiro&lt; 4 &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#ga0bba3bbcd12e3f28d2980995107d27ab">BaseXoroshiro&lt; 8 &gt;</a>, <a class="el" href="class_cwg128.html#a24481951dcf31b56bd6a870ef51a1956">Cwg128</a>, <a class="el" href="class_cwg128__64.html#ad56ed868bbf75282b69de817bfcf403b">Cwg128_64</a>, <a class="el" href="class_cwg64.html#a485e340794178a1633651d5c231484d5">Cwg64</a>, <a class="el" href="group___l_c_g-algorithms.html#ga8da3b012d88e8a5cb232a4c076b950b4">FastRand32</a>, <a class="el" href="group___l_c_g-algorithms.html#ga07a1ac7c9fc2f7507aca4d3de622e77d">FastRand63</a>, <a class="el" href="class_melg19937.html#ab45f3292b3a6ad0e3bcc88956785be3a">Melg19937</a>, <a class="el" href="class_melg44497.html#a0ecdffe713645f1b7a28711ba83c4aa2">Melg44497</a>, <a class="el" href="class_melg607.html#a3ca4a021db56824c9fe47b4bcfe44229">Melg607</a>, <a class="el" href="class_pcg1024__32.html#a0db87ea94b9570da6ea2da5fa90a68e6">Pcg1024_32</a>, <a class="el" href="class_pcg128__64.html#a5ceeec94c1a8cecbaf2a400d49758800">Pcg128_64</a>, and <a class="el" href="class_pcg64__32.html#a3971081bee5a18cc3ca2bec0f306391d">Pcg64_32</a>.</p>

<p class="reference">References <a class="el" href="class_base_random.html#a1bfcea4fbbdbfe98cfd307cfbfba6de7">_setstate()</a>.</p>

</div>
</div>
<a id="gac9cb17b7537a45c9fe06c8c03ba86c00" name="gac9cb17b7537a45c9fe06c8c03ba86c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9cb17b7537a45c9fe06c8c03ba86c00">&#9670;&#160;</a></span>seed() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::seed </td>
          <td>(</td>
          <td class="paramtype">const unsigned long</td>          <td class="paramname"><span class="paramname"><em>seed_</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes internal state from a 32-bits unsigned integer seed. </p>
<p>Initializes internal state from a 32-bits unsigned integer seed. </p>

<p>Reimplemented in <a class="el" href="group___c_w_g-algorithms.html#gad890acd63a607dacbd96d826f70b5364">BaseCWG&lt; ValueType, StateValueType, OutputType, OUTPUT_BITS &gt;</a>, <a class="el" href="group___c_w_g-algorithms.html#gad890acd63a607dacbd96d826f70b5364">BaseCWG&lt; std::uint64_t, std::uint64_t, std::uint64_t, 64 &gt;</a>, <a class="el" href="group___c_w_g-algorithms.html#gad890acd63a607dacbd96d826f70b5364">BaseCWG&lt; std::uint64_t, utils::UInt128, std::uint64_t, 64 &gt;</a>, <a class="el" href="group___c_w_g-algorithms.html#gad890acd63a607dacbd96d826f70b5364">BaseCWG&lt; utils::UInt128, utils::UInt128, utils::UInt128, 128 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga79102a04620d554438b1a07816cd0721">BaseLFib64&lt; SIZE, K &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga79102a04620d554438b1a07816cd0721">BaseLFib64&lt; 1279, 861 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga79102a04620d554438b1a07816cd0721">BaseLFib64&lt; 17, 5 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga79102a04620d554438b1a07816cd0721">BaseLFib64&lt; 55, 24 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga79102a04620d554438b1a07816cd0721">BaseLFib64&lt; 607, 273 &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#ga1f99b55e39018d4af49dfcdab5091360">BaseMELG&lt; SIZE &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#ga1f99b55e39018d4af49dfcdab5091360">BaseMELG&lt; 10 &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#ga1f99b55e39018d4af49dfcdab5091360">BaseMELG&lt; 312 &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#ga1f99b55e39018d4af49dfcdab5091360">BaseMELG&lt; 696 &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#ga15fcf62903e969ce0ee9ac1feb010236">BaseMRG31&lt; SIZE &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#ga15fcf62903e969ce0ee9ac1feb010236">BaseMRG31&lt; 1597 &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#ga15fcf62903e969ce0ee9ac1feb010236">BaseMRG31&lt; 47 &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#ga64659966624ffa17012e7eb2db7d288f">BaseMRG32&lt; SIZE &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#ga64659966624ffa17012e7eb2db7d288f">BaseMRG32&lt; 256 &gt;</a>, <a class="el" href="group___squares-algorithms.html#ga5f4b2aadc6ee7796cb4ad9a1bef26874">BaseSquares&lt; OutputT &gt;</a>, <a class="el" href="group___squares-algorithms.html#ga5f4b2aadc6ee7796cb4ad9a1bef26874">BaseSquares&lt; std::uint32_t &gt;</a>, <a class="el" href="group___squares-algorithms.html#ga5f4b2aadc6ee7796cb4ad9a1bef26874">BaseSquares&lt; std::uint64_t &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#gad088d3e36cfa14295286ef16ff0730d5">BaseWell&lt; SIZE &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#gad088d3e36cfa14295286ef16ff0730d5">BaseWell&lt; 1391 &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#gad088d3e36cfa14295286ef16ff0730d5">BaseWell&lt; 16 &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#gad088d3e36cfa14295286ef16ff0730d5">BaseWell&lt; 32 &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#gad088d3e36cfa14295286ef16ff0730d5">BaseWell&lt; 624 &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#ga7d64b4f698371c5c9f2dd169a955130c">BaseXoroshiro&lt; SIZE &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#ga7d64b4f698371c5c9f2dd169a955130c">BaseXoroshiro&lt; 16 &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#ga7d64b4f698371c5c9f2dd169a955130c">BaseXoroshiro&lt; 4 &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#ga7d64b4f698371c5c9f2dd169a955130c">BaseXoroshiro&lt; 8 &gt;</a>, <a class="el" href="class_cwg128.html#a0151e8f8c84f458f27f8c8cd8d31af07">Cwg128</a>, <a class="el" href="class_cwg128__64.html#aeae09b60347c7ffbee44bde91d7b47ee">Cwg128_64</a>, <a class="el" href="class_cwg64.html#aea15840a2031bba64f501cb2888f7eea">Cwg64</a>, <a class="el" href="group___l_c_g-algorithms.html#ga96038b7a130aace11a5c0d74f74ad3f3">FastRand32</a>, <a class="el" href="group___l_c_g-algorithms.html#gaa63ddc1022b588d403ab361ae555005b">FastRand63</a>, <a class="el" href="class_melg19937.html#a75aa079c3c0ef0ba635a68eea112615a">Melg19937</a>, <a class="el" href="class_melg44497.html#ab1d5a23ab9cb793a50eabe4b55460594">Melg44497</a>, <a class="el" href="class_melg607.html#abc2bfbe1a463914b0d593f6aa14e99c3">Melg607</a>, <a class="el" href="class_pcg1024__32.html#a280927344de70d358ea32052a703b105">Pcg1024_32</a>, <a class="el" href="class_pcg128__64.html#a217248ab2fb0d9a4f48809a2b3b8cb9d">Pcg128_64</a>, and <a class="el" href="class_pcg64__32.html#a71e994a8d5d4ea7d4b915baa001f7b71">Pcg64_32</a>.</p>

<p class="reference">References <a class="el" href="class_base_random.html#a1bfcea4fbbdbfe98cfd307cfbfba6de7">_setstate()</a>.</p>

</div>
</div>
<a id="gaa6d9794a49bc5c6f0639f9c235cc4183" name="gaa6d9794a49bc5c6f0639f9c235cc4183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6d9794a49bc5c6f0639f9c235cc4183">&#9670;&#160;</a></span>seed() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::seed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classutils_1_1_u_int128.html">utils::UInt128</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>seed_</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the internal state of this PRNG with a 128-bits integer seed. </p>
<p>Initializes the internal state of this PRNG with a 128-bits integer seed. </p>

<p>Reimplemented in <a class="el" href="group___c_w_g-algorithms.html#ga50f9db41b61b0df0a7f0e871b164b8d6">BaseCWG&lt; ValueType, StateValueType, OutputType, OUTPUT_BITS &gt;</a>, <a class="el" href="group___c_w_g-algorithms.html#ga50f9db41b61b0df0a7f0e871b164b8d6">BaseCWG&lt; std::uint64_t, std::uint64_t, std::uint64_t, 64 &gt;</a>, <a class="el" href="group___c_w_g-algorithms.html#ga50f9db41b61b0df0a7f0e871b164b8d6">BaseCWG&lt; std::uint64_t, utils::UInt128, std::uint64_t, 64 &gt;</a>, <a class="el" href="group___c_w_g-algorithms.html#ga50f9db41b61b0df0a7f0e871b164b8d6">BaseCWG&lt; utils::UInt128, utils::UInt128, utils::UInt128, 128 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga151036620ea32e3fe0102cfe7213ce41">BaseLFib64&lt; SIZE, K &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga151036620ea32e3fe0102cfe7213ce41">BaseLFib64&lt; 1279, 861 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga151036620ea32e3fe0102cfe7213ce41">BaseLFib64&lt; 17, 5 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga151036620ea32e3fe0102cfe7213ce41">BaseLFib64&lt; 55, 24 &gt;</a>, <a class="el" href="group___l_fib-algorithms.html#ga151036620ea32e3fe0102cfe7213ce41">BaseLFib64&lt; 607, 273 &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#ga858139460bd8c4af86f7434c4733d0dd">BaseMELG&lt; SIZE &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#ga858139460bd8c4af86f7434c4733d0dd">BaseMELG&lt; 10 &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#ga858139460bd8c4af86f7434c4733d0dd">BaseMELG&lt; 312 &gt;</a>, <a class="el" href="group___m_e_l_g-algorithms.html#ga858139460bd8c4af86f7434c4733d0dd">BaseMELG&lt; 696 &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#gad09ff6dc141be48b35a824744514a7de">BaseMRG31&lt; SIZE &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#gad09ff6dc141be48b35a824744514a7de">BaseMRG31&lt; 1597 &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#gad09ff6dc141be48b35a824744514a7de">BaseMRG31&lt; 47 &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#ga55ed0c90ee4c31cee02fc6a23a8db3b5">BaseMRG32&lt; SIZE &gt;</a>, <a class="el" href="group___m_r_g-algorithms.html#ga55ed0c90ee4c31cee02fc6a23a8db3b5">BaseMRG32&lt; 256 &gt;</a>, <a class="el" href="group___squares-algorithms.html#ga322f382cd044b32323f53877a5220fd5">BaseSquares&lt; OutputT &gt;</a>, <a class="el" href="group___squares-algorithms.html#ga322f382cd044b32323f53877a5220fd5">BaseSquares&lt; std::uint32_t &gt;</a>, <a class="el" href="group___squares-algorithms.html#ga322f382cd044b32323f53877a5220fd5">BaseSquares&lt; std::uint64_t &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#gad8206c15cb53771dc7da55dfd3e0ea53">BaseWell&lt; SIZE &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#gad8206c15cb53771dc7da55dfd3e0ea53">BaseWell&lt; 1391 &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#gad8206c15cb53771dc7da55dfd3e0ea53">BaseWell&lt; 16 &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#gad8206c15cb53771dc7da55dfd3e0ea53">BaseWell&lt; 32 &gt;</a>, <a class="el" href="group___w_e_l_l-algorithms.html#gad8206c15cb53771dc7da55dfd3e0ea53">BaseWell&lt; 624 &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#gae616aab5761d6ada7f3dd5d23ec7eff6">BaseXoroshiro&lt; SIZE &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#gae616aab5761d6ada7f3dd5d23ec7eff6">BaseXoroshiro&lt; 16 &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#gae616aab5761d6ada7f3dd5d23ec7eff6">BaseXoroshiro&lt; 4 &gt;</a>, <a class="el" href="group__xoroshiro-algorithms.html#gae616aab5761d6ada7f3dd5d23ec7eff6">BaseXoroshiro&lt; 8 &gt;</a>, <a class="el" href="class_cwg128.html#a317b547415b7915c5a2a265b67c1a30c">Cwg128</a>, <a class="el" href="class_cwg128__64.html#ae83883db1abd1ff5af121b559b336873">Cwg128_64</a>, <a class="el" href="class_cwg64.html#a8de8e2fb75b11a23bc18b14d704200bb">Cwg64</a>, <a class="el" href="group___l_c_g-algorithms.html#ga6c6fe798e7804b75506c10bf6d07cc6c">FastRand32</a>, <a class="el" href="group___l_c_g-algorithms.html#ga710f1d2b981998a1eaf39514f3449315">FastRand63</a>, <a class="el" href="class_melg19937.html#a66cb29f8f58296ab70ed51c57d899c8e">Melg19937</a>, <a class="el" href="class_melg44497.html#ac00ca0e0fe31a6c262c1bb0336ef913e">Melg44497</a>, <a class="el" href="class_melg607.html#a6b2f86bd91e08a1d35a464eabcfe9a0b">Melg607</a>, <a class="el" href="class_pcg1024__32.html#a473e92dfe4ad66a679ab84db106b2466">Pcg1024_32</a>, <a class="el" href="class_pcg128__64.html#ab92294d206027e18784e5717c4e6265e">Pcg128_64</a>, and <a class="el" href="class_pcg64__32.html#a73d79e307303477282554c18124d9a3e">Pcg64_32</a>.</p>

<p class="reference">References <a class="el" href="class_base_random.html#a1bfcea4fbbdbfe98cfd307cfbfba6de7">_setstate()</a>.</p>

</div>
</div>
<a id="ga567817c5860bb6d7fb498e5ada646d84" name="ga567817c5860bb6d7fb498e5ada646d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga567817c5860bb6d7fb498e5ada646d84">&#9670;&#160;</a></span>setstate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::setstate </td>
          <td>(</td>
          <td class="paramtype">const StateT &amp;</td>          <td class="paramname"><span class="paramname"><em>new_internal_state</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the internal state from a new internal state content. </p>
<p>Sets the internal state from a new internal state content. </p>

</div>
</div>
<a id="ga352fcb0394b588ed1419a08e20184184" name="ga352fcb0394b588ed1419a08e20184184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga352fcb0394b588ed1419a08e20184184">&#9670;&#160;</a></span>setstate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::setstate </td>
          <td>(</td>
          <td class="paramtype">const StateT &amp;</td>          <td class="paramname"><span class="paramname"><em>new_internal_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>gauss_next</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the internal state from a new internal state content and with gauss_next. </p>
<p>Sets the internal state from a new internal state content and with gauss_next. </p>

</div>
</div>
<a id="ga3f4cd3ee32d5c3afaca67a51120fa62a" name="ga3f4cd3ee32d5c3afaca67a51120fa62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f4cd3ee32d5c3afaca67a51120fa62a">&#9670;&#160;</a></span>setstate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::setstate </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_base_random_1_1___internal_state.html">_InternalState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>new_internal_state</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restores internal state from object returned by <a class="el" href="class_base_random.html#ad3504565dc9bd81a27af0e00a27eeb83" title="Returns the internal state of this PRNG; can be passed to setstate() later.">getstate()</a>. </p>
<p>Restores internal state from object returned by <a class="el" href="class_base_random.html#ad3504565dc9bd81a27af0e00a27eeb83" title="Returns the internal state of this PRNG; can be passed to setstate() later.">getstate()</a>. </p>

<p class="reference">Referenced by <a class="el" href="class_squares32.html#a7045ae44fe20c6445e652fa94cf2b4a5">Squares32::Squares32()</a>, and <a class="el" href="class_squares64.html#ac475efae4da2122957e47187531f564d">Squares64::Squares64()</a>.</p>

</div>
</div>
<a id="gac997a3ddc920dd8b1762a35f28ab59b1" name="gac997a3ddc920dd8b1762a35f28ab59b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac997a3ddc920dd8b1762a35f28ab59b1">&#9670;&#160;</a></span>shuffle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<div class="memtemplate">
template&lt;typename ContainerType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::shuffle </td>
          <td>(</td>
          <td class="paramtype">ContainerType &amp;</td>          <td class="paramname"><span class="paramname"><em>seq</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shuffles specified sequence in place. </p>
<p>The Container type must be either std::vector or std::array.</p>
<p>Shuffles specified sequence in place. </p>

<p class="reference">References <a class="el" href="#gaca1fbb47b8f64989f590db78a46c3dc9">uniform()</a>.</p>

</div>
</div>
<a id="gaa229184903dab58744e3b44c09060060" name="gaa229184903dab58744e3b44c09060060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa229184903dab58744e3b44c09060060">&#9670;&#160;</a></span>state()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const StateT <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::state </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current internal state value. </p>
<p>Returns the current internal state value. </p>

</div>
</div>
<a id="gad52918dd3d5d0231e67d8f6068f5415c" name="gad52918dd3d5d0231e67d8f6068f5415c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad52918dd3d5d0231e67d8f6068f5415c">&#9670;&#160;</a></span>triangular() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::triangular </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Triangular distribution (low=0.0, high=1.0, mode=0.5). </p>
<p>Triangular distribution (low=0.0, high=1.0, mode=0.5). </p>

<p class="reference">References <a class="el" href="#gad52918dd3d5d0231e67d8f6068f5415c">triangular()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#gad52918dd3d5d0231e67d8f6068f5415c">triangular()</a>, and <a class="el" href="#ga5a885e2900639157c1d4303a8341d773">triangular()</a>.</p>

</div>
</div>
<a id="ga5a885e2900639157c1d4303a8341d773" name="ga5a885e2900639157c1d4303a8341d773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a885e2900639157c1d4303a8341d773">&#9670;&#160;</a></span>triangular() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::triangular </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>low</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>high</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Triangular distribution (low, high, default mode). </p>
<p>Triangular distribution (low, high, default mode). </p>

<p class="reference">References <a class="el" href="#gad52918dd3d5d0231e67d8f6068f5415c">triangular()</a>.</p>

</div>
</div>
<a id="ga0fb0414ad08c26462b8a459063fa500b" name="ga0fb0414ad08c26462b8a459063fa500b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fb0414ad08c26462b8a459063fa500b">&#9670;&#160;</a></span>triangular() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::triangular </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>low</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>high</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>mode</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Triangular distribution (low, high, mode). </p>
<p>Important notice: the implemented code is a translation from Python <a href="https://github.com/python/cpython/blob/3.11/Lib/random.py">https://github.com/python/cpython/blob/3.11/Lib/random.py</a> into c++.</p>
<p>Triangular distribution (low, high, mode). </p>

<p class="reference">References <a class="el" href="#gaca1fbb47b8f64989f590db78a46c3dc9">uniform()</a>.</p>

</div>
</div>
<a id="gaca1fbb47b8f64989f590db78a46c3dc9" name="gaca1fbb47b8f64989f590db78a46c3dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca1fbb47b8f64989f590db78a46c3dc9">&#9670;&#160;</a></span>uniform() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::uniform </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uniform distribution in [0.0, 1.0). </p>
<p>Uniform distribution in [0.0, 1.0). </p>

<p class="reference">References <a class="el" href="class_base_random.html#a5face35abeefcedf8f16b53bf52f1926">random()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#gafc4b4494902512708c6611366b41044d">binomialvariate()</a>, <a class="el" href="#gaea6eb3e08499a26f9ea65250fcf83c19">choice()</a>, <a class="el" href="#gad4d317c0bb6478aab7598b18659eec07">choice()</a>, <a class="el" href="#ga18d7abf6f8898fb186eced8d8db6c40c">expovariate()</a>, <a class="el" href="#ga3d1130df7b8d9630100c810088206596">gammavariate()</a>, <a class="el" href="#gae879ae952c45bad110e45a671fafed3d">gauss()</a>, <a class="el" href="#gac17bfe15bfc24f45f332600c509af0bf">n_evaluate()</a>, <a class="el" href="#gaa6e2821e442bde7866f82bbc5edc198b">n_evaluate()</a>, <a class="el" href="#ga6ca752783b82acd4e8f9234eb4d60457">n_evaluate()</a>, <a class="el" href="#gada9e29de5440f3630cc1ed1200c2addc">n_evaluate()</a>, <a class="el" href="#ga0bbf20019058e6c797ed16a66cb0e276">n_evaluate()</a>, <a class="el" href="#ga806d5a87c263b5d46b6aca1653b9e713">n_evaluate()</a>, <a class="el" href="#ga17f2c7bc2d2887b512a06c70eeb901f2">n_evaluate()</a>, <a class="el" href="#ga68ef9857c13f946fa36bcde40a44b5f5">n_evaluate()</a>, <a class="el" href="#ga42ebf72a2ed001bf641c314bcc838c4f">normalvariate()</a>, <a class="el" href="#gad1546d1ac18402ada9b5caf724662452">operator()()</a>, <a class="el" href="#ga6cf4b50aa446a4dcbbd64ac12e91303b">operator()()</a>, <a class="el" href="#gad46e92e2c0d88d36ed4e9004374b3eb3">operator()()</a>, <a class="el" href="#ga8b8904245206aa7a8bd6a42e6d3fe8f2">operator()()</a>, <a class="el" href="#ga940e175e1dd09f769724a9df85a2287c">operator()()</a>, <a class="el" href="#ga8a3dd28e28eb5c1214289c9bd9a3ab44">operator()()</a>, <a class="el" href="#ga7016b659c3abe67c5088ea8c64260bb6">operator()()</a>, <a class="el" href="#gacb4a9942b0dd52228a8c643c102c7add">paretovariate()</a>, <a class="el" href="#ga8e440e69c5e943e85f8fd778deebb92b">randbytes()</a>, <a class="el" href="#ga2c64096931dc07b192f92c131c2cb047">randint()</a>, <a class="el" href="#ga7dede5e1baced256563617889aef4b74">randrange()</a>, <a class="el" href="#ga1f4df4281975073a3aac23184c87849b">sample()</a>, <a class="el" href="#gafc91ea302c18b4dfc1d01580c83d2a9e">sample()</a>, <a class="el" href="#ga531781fa555945fc7afdcb1de65eaaa3">sample()</a>, <a class="el" href="#gac41f603988ac30aadcd9e805f924ad70">sample()</a>, <a class="el" href="#gac997a3ddc920dd8b1762a35f28ab59b1">shuffle()</a>, <a class="el" href="#ga0fb0414ad08c26462b8a459063fa500b">triangular()</a>, <a class="el" href="#gaa25fa3e19ed9f51a06cb88c95d405916">vonmisesvariate()</a>, and <a class="el" href="#ga9f05337da61ce6f92cc9adb25f6d6224">weibullvariate()</a>.</p>

</div>
</div>
<a id="gac890696338ca27009a01ed05f57d2fab" name="gac890696338ca27009a01ed05f57d2fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac890696338ca27009a01ed05f57d2fab">&#9670;&#160;</a></span>uniform() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<div class="memtemplate">
template&lt;typename T, typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::uniform </td>
          <td>(</td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>max</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uniform distribution in [0.0, max). </p>
<p>Uniform distribution in [0.0, max). </p>

<p class="reference">References <a class="el" href="class_base_random.html#a5face35abeefcedf8f16b53bf52f1926">random()</a>.</p>

</div>
</div>
<a id="ga97883d666a37d5a7a9dddd639c38a6d0" name="ga97883d666a37d5a7a9dddd639c38a6d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97883d666a37d5a7a9dddd639c38a6d0">&#9670;&#160;</a></span>uniform() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
<div class="memtemplate">
template&lt;typename T, typename U, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::uniform </td>
          <td>(</td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V</td>          <td class="paramname"><span class="paramname"><em>max</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uniform distribution in [min, max). </p>
<p>Uniform distribution in [min, max). </p>

<p class="reference">References <a class="el" href="class_base_random.html#a5face35abeefcedf8f16b53bf52f1926">random()</a>.</p>

</div>
</div>
<a id="gaa25fa3e19ed9f51a06cb88c95d405916" name="gaa25fa3e19ed9f51a06cb88c95d405916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa25fa3e19ed9f51a06cb88c95d405916">&#9670;&#160;</a></span>vonmisesvariate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const double <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::vonmisesvariate </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>mu</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>kappa</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Circular data distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mu</td><td>is the mean angle, expressed in radians between 0 and 2*pi </td></tr>
    <tr><td class="paramname">kappa</td><td>is the concentration parameter, which must be greater than or equal to zero. If kappa is equal to zero, this distribution reduces to a uniform random angle over the range 0 to 2*pi.</td></tr>
  </table>
  </dd>
</dl>
<p>Important notice: the implemented code is a translation from Python <a href="https://github.com/python/cpython/blob/3.11/Lib/random.py">https://github.com/python/cpython/blob/3.11/Lib/random.py</a> into c++. As such, some comments present in the Python original code have been copied as is in this c++ implementation, naming then the authors of the related parts of code.</p>
<p>Circular data distribution. </p>

<p class="reference">References <a class="el" href="#gaca1fbb47b8f64989f590db78a46c3dc9">uniform()</a>.</p>

</div>
</div>
<a id="ga9f05337da61ce6f92cc9adb25f6d6224" name="ga9f05337da61ce6f92cc9adb25f6d6224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f05337da61ce6f92cc9adb25f6d6224">&#9670;&#160;</a></span>weibullvariate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateT, typename OutputT, const std::uint8_t OUTPUT_BITS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const double <a class="el" href="class_base_random.html">BaseRandom</a>&lt; StateT, OutputT, OUTPUT_BITS &gt;::weibullvariate </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Weibull distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>double, the scale parameter. </td></tr>
    <tr><td class="paramname">beta</td><td>double, the shape parameter. Must be non null.</td></tr>
  </table>
  </dd>
</dl>
<p>Weibull distribution. </p>

<p class="reference">References <a class="el" href="#gaca1fbb47b8f64989f590db78a46c3dc9">uniform()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on <span class="timestamp"></span> for CppRandLib - c++11 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
